# MMORPG Game Server

## 목표

- 모던 C++로 제작하는 MMORPG 게임 서버
- 유니티 클라이언트와 연동
- 패킷 처리 DB 저장 등의 비동기 처리
- 이동, 스킬 사용 동기화
- 인벤토리 사용

## 서버 코어

### 읽기 락/쓰기 락 구현

#### 읽기 락 정책
- 쓰기 락을 잡고 있지 않는 모든 스레드는 포괄적으로 읽기 락을 획득한다
- 쓰기 락을 잡은 동일 스레드만 읽기 락을 획득할 수 있다
- [쓰기 락 -> 읽기 락]은 허용된다

#### 쓰기 락 정책
- 쓰기 락은 동일 스레드에 한해서만 재귀적으로 락을 획득한다
- 쓰기 락을 획득되면 다른 스레드가 쓰기 락을 획득할 수 없다
- 락 플래그가 EMPTY 상태일 때만 쓰기 락을 획득할 수 있다
- [읽기 락 -> 쓰기 락]은 허용되지 않는다

### 데드락 탐지
- 락 요청 그래프와 락 소유 그래프를 통해 사이클을 탐지한다
  - 스레드 T1이 R1을 보유하고 R2을 요청한다
  - 스레드 T2이 R2을 보유하고 R1을 요청한다
  - R1 -> T1 -> R2 -> T2 -> R1 사이클 생성
- 락을 획득하기 전에 사이클 검사를 수행한다
- 동일 스레드 기준 재귀 획득이 가능하기 때문에 횟수를 카운트한다

### 메모리 풀링
- 모든 크기에 대한 풀링을 하지 않고 32, 64, 96... 4096 크기까지 풀링 사이즈를 미리 정한다
- 외부 단편화를 최소화하며 작은 크기의 잦은 메모리 할당/해제 오버헤드를 제거한다

### 오브젝트 풀링
- 클래스(타입) 단위로 메모리 풀링을 할 필요가 있을 때는 오브젝트 풀링을 한다

### StompAllocator
- VirtualAlloc 등 윈도우 API를 사용해 해제 후 할당 문제와 오버플로우를 감지한다
  - new/delete으로 메모리를 할당받고 해제할 경우 메모리가 힙 매니저에게 반환되고,
  - OS에 언매핑 요청을 하지 않으면 메모리 위반을 검출할 수 없다
  - 디버그 단계에서 _STOMP 매크로를 통해 적용하고 _STOMP를 적용하지 않으면 메모리 풀링이 적용된다

### 잡큐
- 반응성을 높이기 위해 락을 사용하지 않고 일감을 큐에서 순차처리한다
- 지금 프로젝트에서는 맵에서의 패킷 처리를 Room 객체에서 처리한다
- 잡큐를 활용해 모든 처리를 비동기적으로 처리하며 DB 전용 클래스를 통해 데이터를 비동기적으로 저장한다
  - DBSerializer
- 일감을 만들 때는 멤버 함수를 인수로 넘길 수도 있고 람다 함수 안에 로직으로 넘길 수도 있다

## 사용자 검증
### 웹 프로젝트
#### 백엔드: Spring Boot + Spring Security + JPA + Postgresql + JJWT
#### 프론트엔드: Next.js + Typescript + Axios + Formik + React-Query + Recoil + React-Toastify
#### 흐름
1. 사용자가 사이트에서 로그인에 성공하면 서버가 클라이언트에게 액세스 토큰을 발급한다
    - 백엔드 프로젝트에서 jjwt 라이브러리를 사용해 토큰을 발급하고 검증
2. 웹에서 플레이 버튼을 누르면 실행 파일을 시작할 때 토큰과 이메일을 넘긴다
3. 실행 파일이 시작될 때, 이메일의 파싱해서 저장하고 토큰을 파싱해 어플리케이션 서버로 검증을 요청한다
4. 검증에 성공했을 때만 필드로 진입한다

## 컨텐츠
### 플레이어
- 로그인할 때 사용한 이메일의 @와 도메인을 제외한 부분을 플레이어 이름으로 표기한다
- 공격 무기는 화살만 가능
- 몬스터를 잡으면 활, 헬멧, 갑옷, 부츠 등 장비를 획득한다
- 아이템은 몬스터의 수준에 맞게 세팅된다
- ViewCube 객체를 통해 몬스터와의 가시성을 계산한다
  - 맵을 가상으로 나눈 Zone 단위를 통해 인접 Zone에 있는 요소만 렌더링한다
- 더미 플레이어는 별도의 움직임은 없고 ViewCube는 플레이어와 동일한 100ms 주기로 동작한다

### 몬스터
- 200ms 주기로 플레이어를 탐색한다
- A*를 최적화하여 더미 플레이어를 포함한 플레이어를 추적한다
- 타겟 플레이어를 발견했지만 도달할 수 없을 때는 가장 가까운 셀에서 대기할 수 있다
- 플레이어와 특정 거리 이상으로 멀어지면 추격을 중단한다

### 맵
- 가상의 단위인 Zone을 통해 플레이어가 맵에 있는 모든 액터를 렌더링하지 않고 인접 존만 렌더링한다 
  - 인접 Zone의 액터에게만 브로드캐스팅

### ViewCube
- 플레이어의 인접 Zone에 있는 액터들을 구해 100ms 단위로 화면을 갱신한다
- 갱신할 때 추가된 액터는 스폰을 하고 사라진 액터는 디스폰

## 패킷 모아보내기
- 극단적인 반응성이 중요할 때는(FPS 등) 패킷 모아보내기가 유의미하지 않을 수 있지만 MMORPG에서는 많은 패킷을 빠르게 처리하는 건 무시할 수 없는 성능 지표
- CPU 바운드가 IO 바운드보다 압도적으로 빠르기 때문에 이를 활용해 패킷을 모아보낸다
  - 바이트 수와 시간 간격 두 요소를 함께 사용해 패킷이 빨리 쌓이면 빨리 보내고 덜 쌓이더라도 시간 제한을 둔다
- PacketManager를 통해 특정 주기 단위로 패킷이 송신이 이뤄지도록 한다

## 스마트 포인터로 객체 수명 관리
- 메모리 해제를 수동으로 하지 않고 참조 횟수 관리를 통해 자동으로 이뤄지도록 한다

## 복사 비용 최소화
- 복사 비용을 최소화하기 위해 RVO와 이동 연산자를 적극 사용 

## Protobuf 사용
- 유니티 클라이언트와의 원활한 통신을 위해 protobuf를 사용한다
- 코드 자동화와 bat 파일 등을 사용해 패킷이 변경되면 서버와 클라이언트에 동시에 반영될 수 있도록 한다