# MMORPG Game Server

## 목표

- 모던 C++로 제작하는 **2D MMORPG** 게임 서버
- 멀티스레드 프로그래밍
- 유니티 클라이언트를 Protobuf로 연동
- 패킷, DB 저장 등의 비동기 처리
- 이동, 스킬 사용 동기화
- 인벤토리 사용
- 웹 로그인 및 웹에서 실행 파일 실행

## 서버 코어

### 읽기 락/쓰기 락 구현

#### 기본 구현 기술
- C++ 표준의 **cas** 함수를 활용한 스핀 락을 구현한다.
  - `atom` 클래스의 `compare_exchange_weak(x)` 함수 활용한다.
- **cas** 연산을 할 때 `release-acquire` 짝을 맞춰 디폴트의 엄격한 메모리 오더(`seq_cst`)로 인한 불필요 오버헤드를 해소한다.

#### 읽기 락 정책
- **쓰기 락을 잡고 있지 않는 모든 스레드**는 포괄적으로 읽기 락을 획득한다.
- 쓰기 락을 잡은 동일 스레드만 읽기 락을 획득할 수 있다.
- **[쓰기 락 → 읽기 락]** 은 허용된다.

#### 쓰기 락 정책
- 쓰기 락은 동일 스레드에 한해서만 **재귀적으로** 락을 획득한다.
- 쓰기 락을 획득하면 다른 스레드가 쓰기 락을 획득할 수 없다.
- 락 플래그가 **EMPTY** 상태일 때만 쓰기 락을 획득할 수 있다.
- **[읽기 락 → 쓰기 락]** 은 허용되지 않는다.

### 데드락 탐지
- 락 요청 그래프와 락 소유 그래프를 통해 사이클을 탐지한다.
  - 스레드 **T1**이 **R1**을 보유하고 **R2**을 요청한다.
  - 스레드 **T2**이 **R2**을 보유하고 **R1**을 요청한다.
  - **R1 → T1 → R2 → T2 → R1 사이클 생성.**
- 락을 획득하기 전에 **사이클 검사**를 수행한다.
  - 디버그 모드일 때만 수행한다.
- 동일 스레드 재귀 획득이 가능하기 때문에 횟수를 카운트해 획득/해제가 짝을 검사한다.

### 메모리 풀링
#### 과거 버전
- **32, 64, 96... 4096bytes** 크기의 풀링 사이즈를 미리 만든다.
  - **1 ~ 32byte 요청 &nbsp;&nbsp;→ 32byte** 메모리 풀링
  - **33 ~ 64byte 요청  → 64byte** 메모리 풀링
- 외부 단편화를 최소화하며 작은 크기의 잦은 메모리 할당/해제 오버헤드를 제거한다.
- 윈도우에서 제공하는 락 프리 스택 **API**인 **SLIST**를 사용해 메모리를 저장한다.
  - 데이터를 **16 바이트**로 정렬하는 것이 강제되기 때문에 블록 메모리 헤더를 `alignas(x)` 함수로 16 바이트 정렬한다.

- **문제점**
  - 캐시라인의 혜택을 거의 누리지 못한다
    - 락 프리 스택으로 메모리 블록들이 관리되기 때문에 메모리 블록들이 파편화돼서 존재한다.
  - 블록 단위로 발생하는 할당과 반환이 너무 잦아 이로 인한 오버헤드가 누적된다.

#### 새로운 버전(2025.7.1 적용 → 브랜치: with-conversion/update/central-pool-thread-memory-slab)
- **구조**
  - 중앙 풀 + (`ThreadLocal` 객체인) 슬랩 배열이다.
  - 중앙 풀은 요청 크기에 **O(1)** 로 대응할 수 있도록 (과거 버전처럼) 할당 사이즈에 인덱스 크기가 대응하도록 미리 만든다.

- **슬랩 할당**
  - 중앙 풀은 메모리 블록이 아니라 약 **16KB**의 슬랩을 할당한다.
  - 할당 사이즈에 따라 16KB로 나누어 떨어지지 않으면 메모리 블록 만들 때 내부 단편화가 생긴다.
  - 나누어 떨어지는 근사치를 계산해 `SlabInfo` 포인터에 슬랩 사이즈, 블록 카운트, 시작 주소 등을 저장한다.
  - `SlabMetadata`를 생성해  슬랩과 메모리 블록의 헤더로 사용한다.

- **슬랩 반납**
  - 각 스레드 로컬 슬랩에는 자유 메모리 블록 리스트를 가지고 있지만 반환된 메모리를 별도로 관리하지는 않는다.
  - 사용이 끝난 메모리가 반환되는 만큼 카운트를 올리며, 반환 카운트가 블록 카운트와 일치하면 슬랩의 시작 주소를 중앙 풀로 반납한다.
  - 중앙 풀은 메모리 블록을 풀링하는 게 아니라 슬랩을 풀링한다.

- **성능 테스트**
  - 메모리 프로파일러로 잡(Job) 생성에 가장 많은 작업이 할당된다는 것을 확인 후 잡 생성 부분을 새로운 풀링 시스템으로 대체해 테스트한다.
    - 잡 생성에는 오브젝트 풀링이 사용된다.
  
  - **더미 클라이언트 4000명** 테스트 환경이 서버에 이미 큰 부하를 주고 있는 탓에, 서버 전체로는 큰 폭의 성능 개선까지는 아니어도, 캐릭터가 화살을 발사할 때 조금 더 부드러운 느낌이 체감된다.
    - CPU와 RAM 사용률은 모두 이전과 동일하다고 봐도 될 수준이다.
  
  - 12개의 멀티스레드로 단순한 할당/해제를 각 천만 번, **총 1억 2천만 번** 반복 수행하는 테스트에서는 **30배의 성능 향상**이 있었다.
    - 단순한 할당과 해제: **3초 → 0.6초**
    - 컨텐츠 코드에서 주로 사용하는 커스텀 `shared_ptr`에 적용: **30초 → 1초**
    - 새로운 메모리 풀링은 캐시 라인의 혜택을 위해 설계되었으므로 동일한 크기 요청을 반복 수행하면 기존 풀링 시스템보다 유리할 수밖에 없다.
    - [자세한 설명은 블로그](https://literate-t.tistory.com/482)

### 오브젝트 풀링
- 클래스(타입) 단위로 메모리 풀링을 할 수 있다.
- 메모리 풀링을 **랩핑(wrapping)** 해 사용하기 때문에 많은 상황에서 오브젝트 풀링이 사용된다.

### StompAllocator
- `VirtualAlloc` 등 **윈도우 API**를 사용해 **use-after-free** 문제와 오버플로우를 감지한다.
  - `new`와 `delete`으로 메모리를 할당받고 해제할 경우 메모리가 힙 매니저에게 반환되고,
  - OS에 바로 언매핑 요청을 하지 않고 자유 리스트에 추가하디 때문에 메모리 위반을 검출이 어렵다.
  - 디버그 단계에서 _STOMP 매크로를 통해 적용하고 _STOMP를 적용하지 않으면 메모리 풀링이 적용된다.

### StlAllocator
- 표준으로 제공되는 **STL Container**에 **StlAllocator**를 넣은 커스텀 STL을 사용한다.
- **StlAllocator**에서 메모리 할당과 해제에 메모리 풀링이 사용되기 때문에 메모리 할당과 해제로 인한 오버헤드를 줄일 수 있다.

### 잡큐
- 반응성을 높이기 위해 락을 사용하지 않고 일감을 큐에서 순차 처리한다.
- 지금 프로젝트에서는 맵에서의 패킷 처리를 **Room** 객체에서 처리한다.
- 잡큐를 활용해 모든 처리를 비동기적으로 처리하며 DB 전용 클래스를 통해 데이터를 비동기적으로 저장한다.
  - DBSerializer
- 일감을 만들 때는 멤버 함수를 인수로 넘길 수도 있고 람다 함수 안에 로직으로 넘길 수도 있다.

## 사용자 검증
### 웹 프로젝트
**백엔드: Spring Boot + Spring Security + JPA + Postgresql + JJWT**  
**프론트엔드: Next.js + Typescript + Axios + Formik + React-Query + Recoil + React-Toastify**

#### 흐름
1. 사용자가 사이트에서 로그인에 성공하면 서버가 클라이언트에게 액세스 토큰을 발급한다.
    - 백엔드 프로젝트에서 **jjwt** 라이브러리를 사용해 토큰을 발급하고 검증한다.
2. 웹에서 플레이 버튼을 누르면 실행 파일을 시작할 때 토큰과 이메일을 넘긴다.
3. 실행 파일이 시작될 때, 이메일과 토큰을 파싱하고 토큰은 어플리케이션 서버로 검증을 요청한다.
4. 검증에 성공했을 때만 게임 필드로 진입한다.

## 컨텐츠
### 플레이어
- 로그인할 때 사용한 이메일의 @와 도메인을 제외한 부분을 플레이어 이름으로 표기한다.
- 공격 무기는 **화살**만 가능하며 투사체가 동작하는 모습을 확인할 수 있다.
- 몬스터를 잡으면 **활**, **헬멧**, **갑옷**, **부츠** 등 장비를 획득한다.
- 아이템은 몬스터의 수준에 맞게 세팅된다.
- `ViewCube` 객체를 통해 몬스터와의 가시성을 계산한다.
  - 맵을 가상으로 나눈 `Zone` 단위를 통해 인접 `Zone`에 있는 요소만 렌더링한다.
- 더미 플레이어는 움직이지 않지만 `ViewCube`가 플레이어와 동일한 **100ms** 주기로 동작한다.

### 몬스터
- **200ms** 주기로 플레이어를 탐색한다.
- **A***를 최적화하여 더미 플레이어를 포함한 플레이어를 추적한다.
- 타겟 플레이어를 발견했지만 도달할 수 없을 때는 가장 가까운 셀에서 대기할 수 있다.
- 플레이어와 특정 거리 이상으로 멀어지면 추격을 중단한다.

### 맵
- 가상의 단위인 `Zone`을 통해 플레이어가 맵에 있는 모든 액터를 렌더링하지 않고 인접 `Zone`만 렌더링한다.
  - 인접 `Zone`의 액터에게만 브로드캐스팅한다.
- 맵에서 움직이는 모든 액터들은 `Zone`에 속해 있고 `Zone` 변경이 실시간으로 반영된다.

### ViewCube
- 플레이어의 인접 `Zone`에 있는 액터들을 구해 **100ms** 단위로 화면을 갱신한다.
- 갱신할 때 추가된 액터는 스폰을 하고 사라진 액터는 디스폰한다.

## 패킷 모아보내기
- 극단적인 반응성이 중요할 때는(FPS 등) 패킷 모아보내기 적용에 신중해야 한다.
- **CPU 바운드**가 **IO 바운드**보다 압도적으로 빠르기 때문에, 이 프로젝트에서는 초지연성과 더불어 많은 패킷을 처리하기 위해 패킷을 모아보낸다.
  - **바이트 수**와 **시간 간격** 두 요소를 함께 사용해 패킷이 빨리 쌓이면 빨리 보내고 덜 쌓이더라도 시간 제한을 둔다.
- `PacketManager`를 통해 특정 주기 단위로 패킷이 송신이 이뤄지도록 한다.

## 스마트 포인터로 객체 수명 관리
- 메모리 해제를 수동으로 하지 않고 **레퍼런스 카운트**로 자동 관리한다.
- **상호 참조를 통한 순환 구조**가 발생해 메모리가 영원히 해제되지 않는 것을 주의한다.

## 복사 비용 최소화
- 복사 비용을 최소화하기 위해 **RVO**와 **이동 연산자**를 적극 사용한다.
- 컴파일러 옵션으로 **NRVO** 옵션을 추가 적용한다.

## Protobuf 사용
- 유니티 클라이언트와의 원활한 통신을 위해 **protobuf**를 사용한다.
- 코드 자동화와 bat 파일 등을 사용해 패킷이 변경되면 서버와 클라이언트에 동시에 반영될 수 있도록 한다.