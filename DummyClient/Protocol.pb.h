// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C_CreatePlayer;
struct C_CreatePlayerDefaultTypeInternal;
extern C_CreatePlayerDefaultTypeInternal _C_CreatePlayer_default_instance_;
class C_EnterGame;
struct C_EnterGameDefaultTypeInternal;
extern C_EnterGameDefaultTypeInternal _C_EnterGame_default_instance_;
class C_EquipItem;
struct C_EquipItemDefaultTypeInternal;
extern C_EquipItemDefaultTypeInternal _C_EquipItem_default_instance_;
class C_Login;
struct C_LoginDefaultTypeInternal;
extern C_LoginDefaultTypeInternal _C_Login_default_instance_;
class C_Move;
struct C_MoveDefaultTypeInternal;
extern C_MoveDefaultTypeInternal _C_Move_default_instance_;
class C_Pong;
struct C_PongDefaultTypeInternal;
extern C_PongDefaultTypeInternal _C_Pong_default_instance_;
class C_Skill;
struct C_SkillDefaultTypeInternal;
extern C_SkillDefaultTypeInternal _C_Skill_default_instance_;
class C_UseItem;
struct C_UseItemDefaultTypeInternal;
extern C_UseItemDefaultTypeInternal _C_UseItem_default_instance_;
class ItemInfo;
struct ItemInfoDefaultTypeInternal;
extern ItemInfoDefaultTypeInternal _ItemInfo_default_instance_;
class LobbyPlayerInfo;
struct LobbyPlayerInfoDefaultTypeInternal;
extern LobbyPlayerInfoDefaultTypeInternal _LobbyPlayerInfo_default_instance_;
class ObjectInfo;
struct ObjectInfoDefaultTypeInternal;
extern ObjectInfoDefaultTypeInternal _ObjectInfo_default_instance_;
class PositionInfo;
struct PositionInfoDefaultTypeInternal;
extern PositionInfoDefaultTypeInternal _PositionInfo_default_instance_;
class S_AddItem;
struct S_AddItemDefaultTypeInternal;
extern S_AddItemDefaultTypeInternal _S_AddItem_default_instance_;
class S_ChangeHp;
struct S_ChangeHpDefaultTypeInternal;
extern S_ChangeHpDefaultTypeInternal _S_ChangeHp_default_instance_;
class S_ChangeStat;
struct S_ChangeStatDefaultTypeInternal;
extern S_ChangeStatDefaultTypeInternal _S_ChangeStat_default_instance_;
class S_Connected;
struct S_ConnectedDefaultTypeInternal;
extern S_ConnectedDefaultTypeInternal _S_Connected_default_instance_;
class S_CreatePlayer;
struct S_CreatePlayerDefaultTypeInternal;
extern S_CreatePlayerDefaultTypeInternal _S_CreatePlayer_default_instance_;
class S_Despawn;
struct S_DespawnDefaultTypeInternal;
extern S_DespawnDefaultTypeInternal _S_Despawn_default_instance_;
class S_Die;
struct S_DieDefaultTypeInternal;
extern S_DieDefaultTypeInternal _S_Die_default_instance_;
class S_EnterGame;
struct S_EnterGameDefaultTypeInternal;
extern S_EnterGameDefaultTypeInternal _S_EnterGame_default_instance_;
class S_EquipItem;
struct S_EquipItemDefaultTypeInternal;
extern S_EquipItemDefaultTypeInternal _S_EquipItem_default_instance_;
class S_ItemList;
struct S_ItemListDefaultTypeInternal;
extern S_ItemListDefaultTypeInternal _S_ItemList_default_instance_;
class S_LeaveGame;
struct S_LeaveGameDefaultTypeInternal;
extern S_LeaveGameDefaultTypeInternal _S_LeaveGame_default_instance_;
class S_Login;
struct S_LoginDefaultTypeInternal;
extern S_LoginDefaultTypeInternal _S_Login_default_instance_;
class S_Move;
struct S_MoveDefaultTypeInternal;
extern S_MoveDefaultTypeInternal _S_Move_default_instance_;
class S_Ping;
struct S_PingDefaultTypeInternal;
extern S_PingDefaultTypeInternal _S_Ping_default_instance_;
class S_Skill;
struct S_SkillDefaultTypeInternal;
extern S_SkillDefaultTypeInternal _S_Skill_default_instance_;
class S_Spawn;
struct S_SpawnDefaultTypeInternal;
extern S_SpawnDefaultTypeInternal _S_Spawn_default_instance_;
class S_UseItem;
struct S_UseItemDefaultTypeInternal;
extern S_UseItemDefaultTypeInternal _S_UseItem_default_instance_;
class SkillInfo;
struct SkillInfoDefaultTypeInternal;
extern SkillInfoDefaultTypeInternal _SkillInfo_default_instance_;
class StatInfo;
struct StatInfoDefaultTypeInternal;
extern StatInfoDefaultTypeInternal _StatInfo_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_CreatePlayer* Arena::CreateMaybeMessage<::Protocol::C_CreatePlayer>(Arena*);
template<> ::Protocol::C_EnterGame* Arena::CreateMaybeMessage<::Protocol::C_EnterGame>(Arena*);
template<> ::Protocol::C_EquipItem* Arena::CreateMaybeMessage<::Protocol::C_EquipItem>(Arena*);
template<> ::Protocol::C_Login* Arena::CreateMaybeMessage<::Protocol::C_Login>(Arena*);
template<> ::Protocol::C_Move* Arena::CreateMaybeMessage<::Protocol::C_Move>(Arena*);
template<> ::Protocol::C_Pong* Arena::CreateMaybeMessage<::Protocol::C_Pong>(Arena*);
template<> ::Protocol::C_Skill* Arena::CreateMaybeMessage<::Protocol::C_Skill>(Arena*);
template<> ::Protocol::C_UseItem* Arena::CreateMaybeMessage<::Protocol::C_UseItem>(Arena*);
template<> ::Protocol::ItemInfo* Arena::CreateMaybeMessage<::Protocol::ItemInfo>(Arena*);
template<> ::Protocol::LobbyPlayerInfo* Arena::CreateMaybeMessage<::Protocol::LobbyPlayerInfo>(Arena*);
template<> ::Protocol::ObjectInfo* Arena::CreateMaybeMessage<::Protocol::ObjectInfo>(Arena*);
template<> ::Protocol::PositionInfo* Arena::CreateMaybeMessage<::Protocol::PositionInfo>(Arena*);
template<> ::Protocol::S_AddItem* Arena::CreateMaybeMessage<::Protocol::S_AddItem>(Arena*);
template<> ::Protocol::S_ChangeHp* Arena::CreateMaybeMessage<::Protocol::S_ChangeHp>(Arena*);
template<> ::Protocol::S_ChangeStat* Arena::CreateMaybeMessage<::Protocol::S_ChangeStat>(Arena*);
template<> ::Protocol::S_Connected* Arena::CreateMaybeMessage<::Protocol::S_Connected>(Arena*);
template<> ::Protocol::S_CreatePlayer* Arena::CreateMaybeMessage<::Protocol::S_CreatePlayer>(Arena*);
template<> ::Protocol::S_Despawn* Arena::CreateMaybeMessage<::Protocol::S_Despawn>(Arena*);
template<> ::Protocol::S_Die* Arena::CreateMaybeMessage<::Protocol::S_Die>(Arena*);
template<> ::Protocol::S_EnterGame* Arena::CreateMaybeMessage<::Protocol::S_EnterGame>(Arena*);
template<> ::Protocol::S_EquipItem* Arena::CreateMaybeMessage<::Protocol::S_EquipItem>(Arena*);
template<> ::Protocol::S_ItemList* Arena::CreateMaybeMessage<::Protocol::S_ItemList>(Arena*);
template<> ::Protocol::S_LeaveGame* Arena::CreateMaybeMessage<::Protocol::S_LeaveGame>(Arena*);
template<> ::Protocol::S_Login* Arena::CreateMaybeMessage<::Protocol::S_Login>(Arena*);
template<> ::Protocol::S_Move* Arena::CreateMaybeMessage<::Protocol::S_Move>(Arena*);
template<> ::Protocol::S_Ping* Arena::CreateMaybeMessage<::Protocol::S_Ping>(Arena*);
template<> ::Protocol::S_Skill* Arena::CreateMaybeMessage<::Protocol::S_Skill>(Arena*);
template<> ::Protocol::S_Spawn* Arena::CreateMaybeMessage<::Protocol::S_Spawn>(Arena*);
template<> ::Protocol::S_UseItem* Arena::CreateMaybeMessage<::Protocol::S_UseItem>(Arena*);
template<> ::Protocol::SkillInfo* Arena::CreateMaybeMessage<::Protocol::SkillInfo>(Arena*);
template<> ::Protocol::StatInfo* Arena::CreateMaybeMessage<::Protocol::StatInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

enum MessageId : int {
  S_ENTER_GAME = 0,
  S_LEAVE_GAME = 1,
  S_SPAWN = 2,
  S_DESPAWN = 3,
  C_MOVE = 4,
  S_MOVE = 5,
  C_SKILL = 6,
  S_SKILL = 7,
  S_CHANGE_HP = 8,
  S_DIe = 9,
  S_CONNECTED = 10,
  C_LOGIN = 11,
  S_LOGIN = 12,
  C_ENTER_GAME = 13,
  S_CREATE_PLAYER = 14,
  C_CREATE_PLAYER = 15,
  S_ITEM_LIST = 16,
  S_ADD_ITEM = 17,
  C_EQUIP_ITEM = 18,
  S_EQUIP_ITEM = 19,
  S_CHANGE_STAT = 20,
  S_PING = 21,
  C_PONG = 22,
  MessageId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageId_IsValid(int value);
constexpr MessageId MessageId_MIN = S_ENTER_GAME;
constexpr MessageId MessageId_MAX = C_PONG;
constexpr int MessageId_ARRAYSIZE = MessageId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageId_descriptor();
template<typename T>
inline const std::string& MessageId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageId_descriptor(), enum_t_value);
}
inline bool MessageId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageId>(
    MessageId_descriptor(), name, value);
}
enum EntityState : int {
  IDLE = 0,
  MOVING = 1,
  SKILL = 2,
  DEAD = 3,
  EntityState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EntityState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EntityState_IsValid(int value);
constexpr EntityState EntityState_MIN = IDLE;
constexpr EntityState EntityState_MAX = DEAD;
constexpr int EntityState_ARRAYSIZE = EntityState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EntityState_descriptor();
template<typename T>
inline const std::string& EntityState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EntityState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EntityState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EntityState_descriptor(), enum_t_value);
}
inline bool EntityState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EntityState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EntityState>(
    EntityState_descriptor(), name, value);
}
enum MoveDir : int {
  UP = 0,
  DOWN = 1,
  LEFT = 2,
  RIGHT = 3,
  MoveDir_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MoveDir_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MoveDir_IsValid(int value);
constexpr MoveDir MoveDir_MIN = UP;
constexpr MoveDir MoveDir_MAX = RIGHT;
constexpr int MoveDir_ARRAYSIZE = MoveDir_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MoveDir_descriptor();
template<typename T>
inline const std::string& MoveDir_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MoveDir>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MoveDir_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MoveDir_descriptor(), enum_t_value);
}
inline bool MoveDir_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MoveDir* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MoveDir>(
    MoveDir_descriptor(), name, value);
}
enum GameObjectType : int {
  NONE = 0,
  PLAYER = 1,
  MONSTER = 2,
  PROJECTILE = 3,
  GameObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GameObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GameObjectType_IsValid(int value);
constexpr GameObjectType GameObjectType_MIN = NONE;
constexpr GameObjectType GameObjectType_MAX = PROJECTILE;
constexpr int GameObjectType_ARRAYSIZE = GameObjectType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameObjectType_descriptor();
template<typename T>
inline const std::string& GameObjectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameObjectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameObjectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GameObjectType_descriptor(), enum_t_value);
}
inline bool GameObjectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GameObjectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameObjectType>(
    GameObjectType_descriptor(), name, value);
}
enum SkillType : int {
  SKILL_NONE = 0,
  SKILL_AUTO = 1,
  SKILL_PROJECTILE = 2,
  SkillType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SkillType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SkillType_IsValid(int value);
constexpr SkillType SkillType_MIN = SKILL_NONE;
constexpr SkillType SkillType_MAX = SKILL_PROJECTILE;
constexpr int SkillType_ARRAYSIZE = SkillType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SkillType_descriptor();
template<typename T>
inline const std::string& SkillType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SkillType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SkillType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SkillType_descriptor(), enum_t_value);
}
inline bool SkillType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SkillType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SkillType>(
    SkillType_descriptor(), name, value);
}
enum PlayerServerState : int {
  SERVER_STATE_LOGIN = 0,
  SERVER_STATE_LOBBY = 1,
  SERVER_STATE_GAME = 2,
  PlayerServerState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlayerServerState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlayerServerState_IsValid(int value);
constexpr PlayerServerState PlayerServerState_MIN = SERVER_STATE_LOGIN;
constexpr PlayerServerState PlayerServerState_MAX = SERVER_STATE_GAME;
constexpr int PlayerServerState_ARRAYSIZE = PlayerServerState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerServerState_descriptor();
template<typename T>
inline const std::string& PlayerServerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerServerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerServerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerServerState_descriptor(), enum_t_value);
}
inline bool PlayerServerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerServerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerServerState>(
    PlayerServerState_descriptor(), name, value);
}
enum ItemType : int {
  ITEM_TYPE_NONE = 0,
  ITEM_TYPE_WEAPON = 1,
  ITEM_TYPE_ARMOR = 2,
  ITEM_TYPE_CONSUMABLE = 3,
  ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ItemType_IsValid(int value);
constexpr ItemType ItemType_MIN = ITEM_TYPE_NONE;
constexpr ItemType ItemType_MAX = ITEM_TYPE_CONSUMABLE;
constexpr int ItemType_ARRAYSIZE = ItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemType_descriptor();
template<typename T>
inline const std::string& ItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemType_descriptor(), enum_t_value);
}
inline bool ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemType>(
    ItemType_descriptor(), name, value);
}
enum WeaponType : int {
  WEAPON_TYPE_NONE = 0,
  WEAPON_TYPE_SWORD = 1,
  WEAPON_TYPE_BOW = 2,
  WeaponType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WeaponType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WeaponType_IsValid(int value);
constexpr WeaponType WeaponType_MIN = WEAPON_TYPE_NONE;
constexpr WeaponType WeaponType_MAX = WEAPON_TYPE_BOW;
constexpr int WeaponType_ARRAYSIZE = WeaponType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WeaponType_descriptor();
template<typename T>
inline const std::string& WeaponType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeaponType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeaponType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WeaponType_descriptor(), enum_t_value);
}
inline bool WeaponType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WeaponType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WeaponType>(
    WeaponType_descriptor(), name, value);
}
enum ArmorType : int {
  ARMOR_TYPE_NONE = 0,
  ARMOR_TYPE_HELMET = 1,
  ARMOR_TYPE_CHESTARMOR = 2,
  ARMOR_TYPE_BOOTS = 3,
  ArmorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ArmorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ArmorType_IsValid(int value);
constexpr ArmorType ArmorType_MIN = ARMOR_TYPE_NONE;
constexpr ArmorType ArmorType_MAX = ARMOR_TYPE_BOOTS;
constexpr int ArmorType_ARRAYSIZE = ArmorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArmorType_descriptor();
template<typename T>
inline const std::string& ArmorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArmorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArmorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArmorType_descriptor(), enum_t_value);
}
inline bool ArmorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArmorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArmorType>(
    ArmorType_descriptor(), name, value);
}
enum ConsumableType : int {
  CONSUMABLE_TYPE_NONE = 0,
  CONSUMABLE_TYPE_POTION = 1,
  ConsumableType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConsumableType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConsumableType_IsValid(int value);
constexpr ConsumableType ConsumableType_MIN = CONSUMABLE_TYPE_NONE;
constexpr ConsumableType ConsumableType_MAX = CONSUMABLE_TYPE_POTION;
constexpr int ConsumableType_ARRAYSIZE = ConsumableType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConsumableType_descriptor();
template<typename T>
inline const std::string& ConsumableType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConsumableType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConsumableType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConsumableType_descriptor(), enum_t_value);
}
inline bool ConsumableType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConsumableType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConsumableType>(
    ConsumableType_descriptor(), name, value);
}
// ===================================================================

class S_EnterGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EnterGame) */ {
 public:
  inline S_EnterGame() : S_EnterGame(nullptr) {}
  ~S_EnterGame() override;
  explicit PROTOBUF_CONSTEXPR S_EnterGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EnterGame(const S_EnterGame& from);
  S_EnterGame(S_EnterGame&& from) noexcept
    : S_EnterGame() {
    *this = ::std::move(from);
  }

  inline S_EnterGame& operator=(const S_EnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EnterGame& operator=(S_EnterGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EnterGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EnterGame* internal_default_instance() {
    return reinterpret_cast<const S_EnterGame*>(
               &_S_EnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(S_EnterGame& a, S_EnterGame& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EnterGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EnterGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EnterGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EnterGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EnterGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EnterGame& from) {
    S_EnterGame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EnterGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EnterGame";
  }
  protected:
  explicit S_EnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
  };
  // .Protocol.ObjectInfo player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::ObjectInfo& player() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_player();
  ::Protocol::ObjectInfo* mutable_player();
  void set_allocated_player(::Protocol::ObjectInfo* player);
  private:
  const ::Protocol::ObjectInfo& _internal_player() const;
  ::Protocol::ObjectInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::ObjectInfo* player);
  ::Protocol::ObjectInfo* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:Protocol.S_EnterGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* player_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LeaveGame final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_LeaveGame) */ {
 public:
  inline S_LeaveGame() : S_LeaveGame(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_LeaveGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LeaveGame(const S_LeaveGame& from);
  S_LeaveGame(S_LeaveGame&& from) noexcept
    : S_LeaveGame() {
    *this = ::std::move(from);
  }

  inline S_LeaveGame& operator=(const S_LeaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LeaveGame& operator=(S_LeaveGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LeaveGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LeaveGame* internal_default_instance() {
    return reinterpret_cast<const S_LeaveGame*>(
               &_S_LeaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_LeaveGame& a, S_LeaveGame& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LeaveGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LeaveGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LeaveGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LeaveGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_LeaveGame& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_LeaveGame& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LeaveGame";
  }
  protected:
  explicit S_LeaveGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_LeaveGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Spawn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Spawn) */ {
 public:
  inline S_Spawn() : S_Spawn(nullptr) {}
  ~S_Spawn() override;
  explicit PROTOBUF_CONSTEXPR S_Spawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Spawn(const S_Spawn& from);
  S_Spawn(S_Spawn&& from) noexcept
    : S_Spawn() {
    *this = ::std::move(from);
  }

  inline S_Spawn& operator=(const S_Spawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Spawn& operator=(S_Spawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Spawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Spawn* internal_default_instance() {
    return reinterpret_cast<const S_Spawn*>(
               &_S_Spawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(S_Spawn& a, S_Spawn& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Spawn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Spawn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Spawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Spawn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Spawn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_Spawn& from) {
    S_Spawn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Spawn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Spawn";
  }
  protected:
  explicit S_Spawn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 1,
  };
  // repeated .Protocol.ObjectInfo objects = 1;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::Protocol::ObjectInfo* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
      mutable_objects();
  private:
  const ::Protocol::ObjectInfo& _internal_objects(int index) const;
  ::Protocol::ObjectInfo* _internal_add_objects();
  public:
  const ::Protocol::ObjectInfo& objects(int index) const;
  ::Protocol::ObjectInfo* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
      objects() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_Spawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo > objects_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Despawn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Despawn) */ {
 public:
  inline S_Despawn() : S_Despawn(nullptr) {}
  ~S_Despawn() override;
  explicit PROTOBUF_CONSTEXPR S_Despawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Despawn(const S_Despawn& from);
  S_Despawn(S_Despawn&& from) noexcept
    : S_Despawn() {
    *this = ::std::move(from);
  }

  inline S_Despawn& operator=(const S_Despawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Despawn& operator=(S_Despawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Despawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Despawn* internal_default_instance() {
    return reinterpret_cast<const S_Despawn*>(
               &_S_Despawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_Despawn& a, S_Despawn& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Despawn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Despawn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Despawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Despawn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Despawn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_Despawn& from) {
    S_Despawn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Despawn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Despawn";
  }
  protected:
  explicit S_Despawn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdsFieldNumber = 1,
  };
  // repeated int32 objectIds = 1;
  int objectids_size() const;
  private:
  int _internal_objectids_size() const;
  public:
  void clear_objectids();
  private:
  int32_t _internal_objectids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_objectids() const;
  void _internal_add_objectids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_objectids();
  public:
  int32_t objectids(int index) const;
  void set_objectids(int index, int32_t value);
  void add_objectids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      objectids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_objectids();

  // @@protoc_insertion_point(class_scope:Protocol.S_Despawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > objectids_;
    mutable std::atomic<int> _objectids_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Move) */ {
 public:
  inline C_Move() : C_Move(nullptr) {}
  ~C_Move() override;
  explicit PROTOBUF_CONSTEXPR C_Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Move(const C_Move& from);
  C_Move(C_Move&& from) noexcept
    : C_Move() {
    *this = ::std::move(from);
  }

  inline C_Move& operator=(const C_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Move& operator=(C_Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Move* internal_default_instance() {
    return reinterpret_cast<const C_Move*>(
               &_C_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_Move& a, C_Move& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Move* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Move>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Move& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_Move& from) {
    C_Move::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Move* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Move";
  }
  protected:
  explicit C_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 1,
  };
  // .Protocol.PositionInfo posInfo = 1;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PositionInfo& posinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PositionInfo* release_posinfo();
  ::Protocol::PositionInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PositionInfo* posinfo);
  private:
  const ::Protocol::PositionInfo& _internal_posinfo() const;
  ::Protocol::PositionInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PositionInfo* posinfo);
  ::Protocol::PositionInfo* unsafe_arena_release_posinfo();

  // @@protoc_insertion_point(class_scope:Protocol.C_Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PositionInfo* posinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Move) */ {
 public:
  inline S_Move() : S_Move(nullptr) {}
  ~S_Move() override;
  explicit PROTOBUF_CONSTEXPR S_Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Move(const S_Move& from);
  S_Move(S_Move&& from) noexcept
    : S_Move() {
    *this = ::std::move(from);
  }

  inline S_Move& operator=(const S_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Move& operator=(S_Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Move* internal_default_instance() {
    return reinterpret_cast<const S_Move*>(
               &_S_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(S_Move& a, S_Move& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Move* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Move>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Move& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_Move& from) {
    S_Move::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Move* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Move";
  }
  protected:
  explicit S_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 2,
    kObjectIdFieldNumber = 1,
  };
  // .Protocol.PositionInfo posInfo = 2;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PositionInfo& posinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PositionInfo* release_posinfo();
  ::Protocol::PositionInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PositionInfo* posinfo);
  private:
  const ::Protocol::PositionInfo& _internal_posinfo() const;
  ::Protocol::PositionInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PositionInfo* posinfo);
  ::Protocol::PositionInfo* unsafe_arena_release_posinfo();

  // int32 objectId = 1;
  void clear_objectid();
  int32_t objectid() const;
  void set_objectid(int32_t value);
  private:
  int32_t _internal_objectid() const;
  void _internal_set_objectid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PositionInfo* posinfo_;
    int32_t objectid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Skill final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Skill) */ {
 public:
  inline C_Skill() : C_Skill(nullptr) {}
  ~C_Skill() override;
  explicit PROTOBUF_CONSTEXPR C_Skill(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Skill(const C_Skill& from);
  C_Skill(C_Skill&& from) noexcept
    : C_Skill() {
    *this = ::std::move(from);
  }

  inline C_Skill& operator=(const C_Skill& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Skill& operator=(C_Skill&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Skill& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Skill* internal_default_instance() {
    return reinterpret_cast<const C_Skill*>(
               &_C_Skill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(C_Skill& a, C_Skill& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Skill* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Skill* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Skill* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Skill>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Skill& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_Skill& from) {
    C_Skill::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Skill* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Skill";
  }
  protected:
  explicit C_Skill(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.SkillInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::SkillInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::SkillInfo* release_info();
  ::Protocol::SkillInfo* mutable_info();
  void set_allocated_info(::Protocol::SkillInfo* info);
  private:
  const ::Protocol::SkillInfo& _internal_info() const;
  ::Protocol::SkillInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::SkillInfo* info);
  ::Protocol::SkillInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.C_Skill)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::SkillInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Skill final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Skill) */ {
 public:
  inline S_Skill() : S_Skill(nullptr) {}
  ~S_Skill() override;
  explicit PROTOBUF_CONSTEXPR S_Skill(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Skill(const S_Skill& from);
  S_Skill(S_Skill&& from) noexcept
    : S_Skill() {
    *this = ::std::move(from);
  }

  inline S_Skill& operator=(const S_Skill& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Skill& operator=(S_Skill&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Skill& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Skill* internal_default_instance() {
    return reinterpret_cast<const S_Skill*>(
               &_S_Skill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(S_Skill& a, S_Skill& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Skill* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Skill* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Skill* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Skill>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Skill& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_Skill& from) {
    S_Skill::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Skill* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Skill";
  }
  protected:
  explicit S_Skill(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kObjectIdFieldNumber = 1,
  };
  // .Protocol.SkillInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::SkillInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::SkillInfo* release_info();
  ::Protocol::SkillInfo* mutable_info();
  void set_allocated_info(::Protocol::SkillInfo* info);
  private:
  const ::Protocol::SkillInfo& _internal_info() const;
  ::Protocol::SkillInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::SkillInfo* info);
  ::Protocol::SkillInfo* unsafe_arena_release_info();

  // int32 objectId = 1;
  void clear_objectid();
  int32_t objectid() const;
  void set_objectid(int32_t value);
  private:
  int32_t _internal_objectid() const;
  void _internal_set_objectid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Skill)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::SkillInfo* info_;
    int32_t objectid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ChangeHp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ChangeHp) */ {
 public:
  inline S_ChangeHp() : S_ChangeHp(nullptr) {}
  ~S_ChangeHp() override;
  explicit PROTOBUF_CONSTEXPR S_ChangeHp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ChangeHp(const S_ChangeHp& from);
  S_ChangeHp(S_ChangeHp&& from) noexcept
    : S_ChangeHp() {
    *this = ::std::move(from);
  }

  inline S_ChangeHp& operator=(const S_ChangeHp& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ChangeHp& operator=(S_ChangeHp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ChangeHp& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ChangeHp* internal_default_instance() {
    return reinterpret_cast<const S_ChangeHp*>(
               &_S_ChangeHp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_ChangeHp& a, S_ChangeHp& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ChangeHp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ChangeHp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ChangeHp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ChangeHp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ChangeHp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ChangeHp& from) {
    S_ChangeHp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ChangeHp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ChangeHp";
  }
  protected:
  explicit S_ChangeHp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kHpFieldNumber = 2,
  };
  // int32 objectId = 1;
  void clear_objectid();
  int32_t objectid() const;
  void set_objectid(int32_t value);
  private:
  int32_t _internal_objectid() const;
  void _internal_set_objectid(int32_t value);
  public:

  // int32 hp = 2;
  void clear_hp();
  int32_t hp() const;
  void set_hp(int32_t value);
  private:
  int32_t _internal_hp() const;
  void _internal_set_hp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ChangeHp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t objectid_;
    int32_t hp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Die final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Die) */ {
 public:
  inline S_Die() : S_Die(nullptr) {}
  ~S_Die() override;
  explicit PROTOBUF_CONSTEXPR S_Die(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Die(const S_Die& from);
  S_Die(S_Die&& from) noexcept
    : S_Die() {
    *this = ::std::move(from);
  }

  inline S_Die& operator=(const S_Die& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Die& operator=(S_Die&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Die& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Die* internal_default_instance() {
    return reinterpret_cast<const S_Die*>(
               &_S_Die_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(S_Die& a, S_Die& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Die* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Die* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Die* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Die>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Die& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_Die& from) {
    S_Die::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Die* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Die";
  }
  protected:
  explicit S_Die(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAttackerIdFieldNumber = 2,
  };
  // int32 objectId = 1;
  void clear_objectid();
  int32_t objectid() const;
  void set_objectid(int32_t value);
  private:
  int32_t _internal_objectid() const;
  void _internal_set_objectid(int32_t value);
  public:

  // int32 attackerId = 2;
  void clear_attackerid();
  int32_t attackerid() const;
  void set_attackerid(int32_t value);
  private:
  int32_t _internal_attackerid() const;
  void _internal_set_attackerid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Die)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t objectid_;
    int32_t attackerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Connected final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_Connected) */ {
 public:
  inline S_Connected() : S_Connected(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_Connected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Connected(const S_Connected& from);
  S_Connected(S_Connected&& from) noexcept
    : S_Connected() {
    *this = ::std::move(from);
  }

  inline S_Connected& operator=(const S_Connected& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Connected& operator=(S_Connected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Connected& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Connected* internal_default_instance() {
    return reinterpret_cast<const S_Connected*>(
               &_S_Connected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(S_Connected& a, S_Connected& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Connected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Connected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Connected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Connected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_Connected& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_Connected& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Connected";
  }
  protected:
  explicit S_Connected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_Connected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Login) */ {
 public:
  inline C_Login() : C_Login(nullptr) {}
  ~C_Login() override;
  explicit PROTOBUF_CONSTEXPR C_Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Login(const C_Login& from);
  C_Login(C_Login&& from) noexcept
    : C_Login() {
    *this = ::std::move(from);
  }

  inline C_Login& operator=(const C_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Login& operator=(C_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Login* internal_default_instance() {
    return reinterpret_cast<const C_Login*>(
               &_C_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(C_Login& a, C_Login& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Login* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_Login& from) {
    C_Login::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Login* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Login";
  }
  protected:
  explicit C_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniqueIdFieldNumber = 1,
  };
  // string uniqueId = 1;
  void clear_uniqueid();
  const std::string& uniqueid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uniqueid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uniqueid();
  PROTOBUF_NODISCARD std::string* release_uniqueid();
  void set_allocated_uniqueid(std::string* uniqueid);
  private:
  const std::string& _internal_uniqueid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uniqueid(const std::string& value);
  std::string* _internal_mutable_uniqueid();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uniqueid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Login) */ {
 public:
  inline S_Login() : S_Login(nullptr) {}
  ~S_Login() override;
  explicit PROTOBUF_CONSTEXPR S_Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Login(const S_Login& from);
  S_Login(S_Login&& from) noexcept
    : S_Login() {
    *this = ::std::move(from);
  }

  inline S_Login& operator=(const S_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Login& operator=(S_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Login* internal_default_instance() {
    return reinterpret_cast<const S_Login*>(
               &_S_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S_Login& a, S_Login& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Login* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_Login& from) {
    S_Login::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Login* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Login";
  }
  protected:
  explicit S_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 2,
    kLoginOkFieldNumber = 1,
  };
  // repeated .Protocol.LobbyPlayerInfo players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::LobbyPlayerInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo >*
      mutable_players();
  private:
  const ::Protocol::LobbyPlayerInfo& _internal_players(int index) const;
  ::Protocol::LobbyPlayerInfo* _internal_add_players();
  public:
  const ::Protocol::LobbyPlayerInfo& players(int index) const;
  ::Protocol::LobbyPlayerInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo >&
      players() const;

  // int32 loginOk = 1;
  void clear_loginok();
  int32_t loginok() const;
  void set_loginok(int32_t value);
  private:
  int32_t _internal_loginok() const;
  void _internal_set_loginok(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo > players_;
    int32_t loginok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EnterGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EnterGame) */ {
 public:
  inline C_EnterGame() : C_EnterGame(nullptr) {}
  ~C_EnterGame() override;
  explicit PROTOBUF_CONSTEXPR C_EnterGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EnterGame(const C_EnterGame& from);
  C_EnterGame(C_EnterGame&& from) noexcept
    : C_EnterGame() {
    *this = ::std::move(from);
  }

  inline C_EnterGame& operator=(const C_EnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EnterGame& operator=(C_EnterGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EnterGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EnterGame* internal_default_instance() {
    return reinterpret_cast<const C_EnterGame*>(
               &_C_EnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(C_EnterGame& a, C_EnterGame& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EnterGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EnterGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EnterGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EnterGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EnterGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_EnterGame& from) {
    C_EnterGame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EnterGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EnterGame";
  }
  protected:
  explicit C_EnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_EnterGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CreatePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CreatePlayer) */ {
 public:
  inline S_CreatePlayer() : S_CreatePlayer(nullptr) {}
  ~S_CreatePlayer() override;
  explicit PROTOBUF_CONSTEXPR S_CreatePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CreatePlayer(const S_CreatePlayer& from);
  S_CreatePlayer(S_CreatePlayer&& from) noexcept
    : S_CreatePlayer() {
    *this = ::std::move(from);
  }

  inline S_CreatePlayer& operator=(const S_CreatePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CreatePlayer& operator=(S_CreatePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CreatePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CreatePlayer* internal_default_instance() {
    return reinterpret_cast<const S_CreatePlayer*>(
               &_S_CreatePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_CreatePlayer& a, S_CreatePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CreatePlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CreatePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CreatePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CreatePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CreatePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CreatePlayer& from) {
    S_CreatePlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CreatePlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CreatePlayer";
  }
  protected:
  explicit S_CreatePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
  };
  // .Protocol.LobbyPlayerInfo player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::LobbyPlayerInfo& player() const;
  PROTOBUF_NODISCARD ::Protocol::LobbyPlayerInfo* release_player();
  ::Protocol::LobbyPlayerInfo* mutable_player();
  void set_allocated_player(::Protocol::LobbyPlayerInfo* player);
  private:
  const ::Protocol::LobbyPlayerInfo& _internal_player() const;
  ::Protocol::LobbyPlayerInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::LobbyPlayerInfo* player);
  ::Protocol::LobbyPlayerInfo* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:Protocol.S_CreatePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::LobbyPlayerInfo* player_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CreatePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CreatePlayer) */ {
 public:
  inline C_CreatePlayer() : C_CreatePlayer(nullptr) {}
  ~C_CreatePlayer() override;
  explicit PROTOBUF_CONSTEXPR C_CreatePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CreatePlayer(const C_CreatePlayer& from);
  C_CreatePlayer(C_CreatePlayer&& from) noexcept
    : C_CreatePlayer() {
    *this = ::std::move(from);
  }

  inline C_CreatePlayer& operator=(const C_CreatePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CreatePlayer& operator=(C_CreatePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CreatePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CreatePlayer* internal_default_instance() {
    return reinterpret_cast<const C_CreatePlayer*>(
               &_C_CreatePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(C_CreatePlayer& a, C_CreatePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CreatePlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CreatePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CreatePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CreatePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CreatePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CreatePlayer& from) {
    C_CreatePlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CreatePlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CreatePlayer";
  }
  protected:
  explicit C_CreatePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CreatePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ItemList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ItemList) */ {
 public:
  inline S_ItemList() : S_ItemList(nullptr) {}
  ~S_ItemList() override;
  explicit PROTOBUF_CONSTEXPR S_ItemList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ItemList(const S_ItemList& from);
  S_ItemList(S_ItemList&& from) noexcept
    : S_ItemList() {
    *this = ::std::move(from);
  }

  inline S_ItemList& operator=(const S_ItemList& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ItemList& operator=(S_ItemList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ItemList& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ItemList* internal_default_instance() {
    return reinterpret_cast<const S_ItemList*>(
               &_S_ItemList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(S_ItemList& a, S_ItemList& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ItemList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ItemList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ItemList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ItemList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ItemList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ItemList& from) {
    S_ItemList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ItemList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ItemList";
  }
  protected:
  explicit S_ItemList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .Protocol.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_items();
  private:
  const ::Protocol::ItemInfo& _internal_items(int index) const;
  ::Protocol::ItemInfo* _internal_add_items();
  public:
  const ::Protocol::ItemInfo& items(int index) const;
  ::Protocol::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_ItemList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AddItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AddItem) */ {
 public:
  inline S_AddItem() : S_AddItem(nullptr) {}
  ~S_AddItem() override;
  explicit PROTOBUF_CONSTEXPR S_AddItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AddItem(const S_AddItem& from);
  S_AddItem(S_AddItem&& from) noexcept
    : S_AddItem() {
    *this = ::std::move(from);
  }

  inline S_AddItem& operator=(const S_AddItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AddItem& operator=(S_AddItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AddItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AddItem* internal_default_instance() {
    return reinterpret_cast<const S_AddItem*>(
               &_S_AddItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(S_AddItem& a, S_AddItem& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AddItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AddItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AddItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AddItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AddItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AddItem& from) {
    S_AddItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AddItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AddItem";
  }
  protected:
  explicit S_AddItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .Protocol.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_items();
  private:
  const ::Protocol::ItemInfo& _internal_items(int index) const;
  ::Protocol::ItemInfo* _internal_add_items();
  public:
  const ::Protocol::ItemInfo& items(int index) const;
  ::Protocol::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_AddItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EquipItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EquipItem) */ {
 public:
  inline C_EquipItem() : C_EquipItem(nullptr) {}
  ~C_EquipItem() override;
  explicit PROTOBUF_CONSTEXPR C_EquipItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EquipItem(const C_EquipItem& from);
  C_EquipItem(C_EquipItem&& from) noexcept
    : C_EquipItem() {
    *this = ::std::move(from);
  }

  inline C_EquipItem& operator=(const C_EquipItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EquipItem& operator=(C_EquipItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EquipItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EquipItem* internal_default_instance() {
    return reinterpret_cast<const C_EquipItem*>(
               &_C_EquipItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(C_EquipItem& a, C_EquipItem& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EquipItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EquipItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EquipItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EquipItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EquipItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_EquipItem& from) {
    C_EquipItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EquipItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EquipItem";
  }
  protected:
  explicit C_EquipItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotFieldNumber = 1,
    kEquippedFieldNumber = 2,
  };
  // int32 slot = 1;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // bool equipped = 2;
  void clear_equipped();
  bool equipped() const;
  void set_equipped(bool value);
  private:
  bool _internal_equipped() const;
  void _internal_set_equipped(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_EquipItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t slot_;
    bool equipped_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EquipItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EquipItem) */ {
 public:
  inline S_EquipItem() : S_EquipItem(nullptr) {}
  ~S_EquipItem() override;
  explicit PROTOBUF_CONSTEXPR S_EquipItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EquipItem(const S_EquipItem& from);
  S_EquipItem(S_EquipItem&& from) noexcept
    : S_EquipItem() {
    *this = ::std::move(from);
  }

  inline S_EquipItem& operator=(const S_EquipItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EquipItem& operator=(S_EquipItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EquipItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EquipItem* internal_default_instance() {
    return reinterpret_cast<const S_EquipItem*>(
               &_S_EquipItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(S_EquipItem& a, S_EquipItem& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EquipItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EquipItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EquipItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EquipItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EquipItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EquipItem& from) {
    S_EquipItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EquipItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EquipItem";
  }
  protected:
  explicit S_EquipItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotFieldNumber = 1,
    kEquippedFieldNumber = 2,
  };
  // int32 slot = 1;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // bool equipped = 2;
  void clear_equipped();
  bool equipped() const;
  void set_equipped(bool value);
  private:
  bool _internal_equipped() const;
  void _internal_set_equipped(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EquipItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t slot_;
    bool equipped_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_UseItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_UseItem) */ {
 public:
  inline C_UseItem() : C_UseItem(nullptr) {}
  ~C_UseItem() override;
  explicit PROTOBUF_CONSTEXPR C_UseItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_UseItem(const C_UseItem& from);
  C_UseItem(C_UseItem&& from) noexcept
    : C_UseItem() {
    *this = ::std::move(from);
  }

  inline C_UseItem& operator=(const C_UseItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_UseItem& operator=(C_UseItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_UseItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_UseItem* internal_default_instance() {
    return reinterpret_cast<const C_UseItem*>(
               &_C_UseItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(C_UseItem& a, C_UseItem& b) {
    a.Swap(&b);
  }
  inline void Swap(C_UseItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_UseItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_UseItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_UseItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_UseItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_UseItem& from) {
    C_UseItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_UseItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_UseItem";
  }
  protected:
  explicit C_UseItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotFieldNumber = 1,
  };
  // int32 slot = 1;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_UseItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t slot_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_UseItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_UseItem) */ {
 public:
  inline S_UseItem() : S_UseItem(nullptr) {}
  ~S_UseItem() override;
  explicit PROTOBUF_CONSTEXPR S_UseItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_UseItem(const S_UseItem& from);
  S_UseItem(S_UseItem&& from) noexcept
    : S_UseItem() {
    *this = ::std::move(from);
  }

  inline S_UseItem& operator=(const S_UseItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_UseItem& operator=(S_UseItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_UseItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_UseItem* internal_default_instance() {
    return reinterpret_cast<const S_UseItem*>(
               &_S_UseItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(S_UseItem& a, S_UseItem& b) {
    a.Swap(&b);
  }
  inline void Swap(S_UseItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_UseItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_UseItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_UseItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_UseItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_UseItem& from) {
    S_UseItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_UseItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_UseItem";
  }
  protected:
  explicit S_UseItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotFieldNumber = 1,
  };
  // int32 slot = 1;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_UseItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t slot_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ChangeStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ChangeStat) */ {
 public:
  inline S_ChangeStat() : S_ChangeStat(nullptr) {}
  ~S_ChangeStat() override;
  explicit PROTOBUF_CONSTEXPR S_ChangeStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ChangeStat(const S_ChangeStat& from);
  S_ChangeStat(S_ChangeStat&& from) noexcept
    : S_ChangeStat() {
    *this = ::std::move(from);
  }

  inline S_ChangeStat& operator=(const S_ChangeStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ChangeStat& operator=(S_ChangeStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ChangeStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ChangeStat* internal_default_instance() {
    return reinterpret_cast<const S_ChangeStat*>(
               &_S_ChangeStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(S_ChangeStat& a, S_ChangeStat& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ChangeStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ChangeStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ChangeStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ChangeStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ChangeStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ChangeStat& from) {
    S_ChangeStat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ChangeStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ChangeStat";
  }
  protected:
  explicit S_ChangeStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatInfoFieldNumber = 1,
  };
  // .Protocol.StatInfo statInfo = 1;
  bool has_statinfo() const;
  private:
  bool _internal_has_statinfo() const;
  public:
  void clear_statinfo();
  const ::Protocol::StatInfo& statinfo() const;
  PROTOBUF_NODISCARD ::Protocol::StatInfo* release_statinfo();
  ::Protocol::StatInfo* mutable_statinfo();
  void set_allocated_statinfo(::Protocol::StatInfo* statinfo);
  private:
  const ::Protocol::StatInfo& _internal_statinfo() const;
  ::Protocol::StatInfo* _internal_mutable_statinfo();
  public:
  void unsafe_arena_set_allocated_statinfo(
      ::Protocol::StatInfo* statinfo);
  ::Protocol::StatInfo* unsafe_arena_release_statinfo();

  // @@protoc_insertion_point(class_scope:Protocol.S_ChangeStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::StatInfo* statinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Ping final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_Ping) */ {
 public:
  inline S_Ping() : S_Ping(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_Ping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Ping(const S_Ping& from);
  S_Ping(S_Ping&& from) noexcept
    : S_Ping() {
    *this = ::std::move(from);
  }

  inline S_Ping& operator=(const S_Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Ping& operator=(S_Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Ping* internal_default_instance() {
    return reinterpret_cast<const S_Ping*>(
               &_S_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(S_Ping& a, S_Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Ping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Ping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_Ping& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_Ping& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Ping";
  }
  protected:
  explicit S_Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Pong final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_Pong) */ {
 public:
  inline C_Pong() : C_Pong(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_Pong(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Pong(const C_Pong& from);
  C_Pong(C_Pong&& from) noexcept
    : C_Pong() {
    *this = ::std::move(from);
  }

  inline C_Pong& operator=(const C_Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Pong& operator=(C_Pong&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Pong& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Pong* internal_default_instance() {
    return reinterpret_cast<const C_Pong*>(
               &_C_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(C_Pong& a, C_Pong& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Pong* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Pong* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Pong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Pong>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_Pong& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_Pong& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Pong";
  }
  protected:
  explicit C_Pong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_Pong)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class ObjectInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ObjectInfo) */ {
 public:
  inline ObjectInfo() : ObjectInfo(nullptr) {}
  ~ObjectInfo() override;
  explicit PROTOBUF_CONSTEXPR ObjectInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectInfo(const ObjectInfo& from);
  ObjectInfo(ObjectInfo&& from) noexcept
    : ObjectInfo() {
    *this = ::std::move(from);
  }

  inline ObjectInfo& operator=(const ObjectInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectInfo& operator=(ObjectInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectInfo* internal_default_instance() {
    return reinterpret_cast<const ObjectInfo*>(
               &_ObjectInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ObjectInfo& a, ObjectInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectInfo& from) {
    ObjectInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ObjectInfo";
  }
  protected:
  explicit ObjectInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kPosInfoFieldNumber = 3,
    kStatInfoFieldNumber = 4,
    kObjectIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Protocol.PositionInfo posInfo = 3;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PositionInfo& posinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PositionInfo* release_posinfo();
  ::Protocol::PositionInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PositionInfo* posinfo);
  private:
  const ::Protocol::PositionInfo& _internal_posinfo() const;
  ::Protocol::PositionInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PositionInfo* posinfo);
  ::Protocol::PositionInfo* unsafe_arena_release_posinfo();

  // .Protocol.StatInfo statInfo = 4;
  bool has_statinfo() const;
  private:
  bool _internal_has_statinfo() const;
  public:
  void clear_statinfo();
  const ::Protocol::StatInfo& statinfo() const;
  PROTOBUF_NODISCARD ::Protocol::StatInfo* release_statinfo();
  ::Protocol::StatInfo* mutable_statinfo();
  void set_allocated_statinfo(::Protocol::StatInfo* statinfo);
  private:
  const ::Protocol::StatInfo& _internal_statinfo() const;
  ::Protocol::StatInfo* _internal_mutable_statinfo();
  public:
  void unsafe_arena_set_allocated_statinfo(
      ::Protocol::StatInfo* statinfo);
  ::Protocol::StatInfo* unsafe_arena_release_statinfo();

  // int32 objectId = 1;
  void clear_objectid();
  int32_t objectid() const;
  void set_objectid(int32_t value);
  private:
  int32_t _internal_objectid() const;
  void _internal_set_objectid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ObjectInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::Protocol::PositionInfo* posinfo_;
    ::Protocol::StatInfo* statinfo_;
    int32_t objectid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class LobbyPlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.LobbyPlayerInfo) */ {
 public:
  inline LobbyPlayerInfo() : LobbyPlayerInfo(nullptr) {}
  ~LobbyPlayerInfo() override;
  explicit PROTOBUF_CONSTEXPR LobbyPlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyPlayerInfo(const LobbyPlayerInfo& from);
  LobbyPlayerInfo(LobbyPlayerInfo&& from) noexcept
    : LobbyPlayerInfo() {
    *this = ::std::move(from);
  }

  inline LobbyPlayerInfo& operator=(const LobbyPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyPlayerInfo& operator=(LobbyPlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyPlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LobbyPlayerInfo* internal_default_instance() {
    return reinterpret_cast<const LobbyPlayerInfo*>(
               &_LobbyPlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LobbyPlayerInfo& a, LobbyPlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyPlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyPlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbyPlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LobbyPlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyPlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LobbyPlayerInfo& from) {
    LobbyPlayerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyPlayerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.LobbyPlayerInfo";
  }
  protected:
  explicit LobbyPlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kStatInfoFieldNumber = 3,
    kPlayerDbIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Protocol.StatInfo statInfo = 3;
  bool has_statinfo() const;
  private:
  bool _internal_has_statinfo() const;
  public:
  void clear_statinfo();
  const ::Protocol::StatInfo& statinfo() const;
  PROTOBUF_NODISCARD ::Protocol::StatInfo* release_statinfo();
  ::Protocol::StatInfo* mutable_statinfo();
  void set_allocated_statinfo(::Protocol::StatInfo* statinfo);
  private:
  const ::Protocol::StatInfo& _internal_statinfo() const;
  ::Protocol::StatInfo* _internal_mutable_statinfo();
  public:
  void unsafe_arena_set_allocated_statinfo(
      ::Protocol::StatInfo* statinfo);
  ::Protocol::StatInfo* unsafe_arena_release_statinfo();

  // int32 playerDbId = 1;
  void clear_playerdbid();
  int32_t playerdbid() const;
  void set_playerdbid(int32_t value);
  private:
  int32_t _internal_playerdbid() const;
  void _internal_set_playerdbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.LobbyPlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::Protocol::StatInfo* statinfo_;
    int32_t playerdbid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class PositionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PositionInfo) */ {
 public:
  inline PositionInfo() : PositionInfo(nullptr) {}
  ~PositionInfo() override;
  explicit PROTOBUF_CONSTEXPR PositionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PositionInfo(const PositionInfo& from);
  PositionInfo(PositionInfo&& from) noexcept
    : PositionInfo() {
    *this = ::std::move(from);
  }

  inline PositionInfo& operator=(const PositionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionInfo& operator=(PositionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionInfo* internal_default_instance() {
    return reinterpret_cast<const PositionInfo*>(
               &_PositionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PositionInfo& a, PositionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PositionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PositionInfo& from) {
    PositionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PositionInfo";
  }
  protected:
  explicit PositionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
    kMoveDirFieldNumber = 2,
    kPosXFieldNumber = 3,
    kPosYFieldNumber = 4,
  };
  // .Protocol.EntityState state = 1;
  void clear_state();
  ::Protocol::EntityState state() const;
  void set_state(::Protocol::EntityState value);
  private:
  ::Protocol::EntityState _internal_state() const;
  void _internal_set_state(::Protocol::EntityState value);
  public:

  // .Protocol.MoveDir moveDir = 2;
  void clear_movedir();
  ::Protocol::MoveDir movedir() const;
  void set_movedir(::Protocol::MoveDir value);
  private:
  ::Protocol::MoveDir _internal_movedir() const;
  void _internal_set_movedir(::Protocol::MoveDir value);
  public:

  // int32 PosX = 3;
  void clear_posx();
  int32_t posx() const;
  void set_posx(int32_t value);
  private:
  int32_t _internal_posx() const;
  void _internal_set_posx(int32_t value);
  public:

  // int32 PosY = 4;
  void clear_posy();
  int32_t posy() const;
  void set_posy(int32_t value);
  private:
  int32_t _internal_posy() const;
  void _internal_set_posy(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PositionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int state_;
    int movedir_;
    int32_t posx_;
    int32_t posy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class StatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.StatInfo) */ {
 public:
  inline StatInfo() : StatInfo(nullptr) {}
  ~StatInfo() override;
  explicit PROTOBUF_CONSTEXPR StatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatInfo(const StatInfo& from);
  StatInfo(StatInfo&& from) noexcept
    : StatInfo() {
    *this = ::std::move(from);
  }

  inline StatInfo& operator=(const StatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatInfo& operator=(StatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatInfo* internal_default_instance() {
    return reinterpret_cast<const StatInfo*>(
               &_StatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(StatInfo& a, StatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StatInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatInfo& from) {
    StatInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.StatInfo";
  }
  protected:
  explicit StatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
    kHpFieldNumber = 2,
    kMaxHpFieldNumber = 3,
    kAttackFieldNumber = 4,
    kSpeedFieldNumber = 5,
    kTotalExpFieldNumber = 6,
  };
  // int32 level = 1;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // int32 hp = 2;
  void clear_hp();
  int32_t hp() const;
  void set_hp(int32_t value);
  private:
  int32_t _internal_hp() const;
  void _internal_set_hp(int32_t value);
  public:

  // int32 maxHp = 3;
  void clear_maxhp();
  int32_t maxhp() const;
  void set_maxhp(int32_t value);
  private:
  int32_t _internal_maxhp() const;
  void _internal_set_maxhp(int32_t value);
  public:

  // int32 attack = 4;
  void clear_attack();
  int32_t attack() const;
  void set_attack(int32_t value);
  private:
  int32_t _internal_attack() const;
  void _internal_set_attack(int32_t value);
  public:

  // float speed = 5;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // int32 totalExp = 6;
  void clear_totalexp();
  int32_t totalexp() const;
  void set_totalexp(int32_t value);
  private:
  int32_t _internal_totalexp() const;
  void _internal_set_totalexp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.StatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t level_;
    int32_t hp_;
    int32_t maxhp_;
    int32_t attack_;
    float speed_;
    int32_t totalexp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class SkillInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SkillInfo) */ {
 public:
  inline SkillInfo() : SkillInfo(nullptr) {}
  ~SkillInfo() override;
  explicit PROTOBUF_CONSTEXPR SkillInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SkillInfo(const SkillInfo& from);
  SkillInfo(SkillInfo&& from) noexcept
    : SkillInfo() {
    *this = ::std::move(from);
  }

  inline SkillInfo& operator=(const SkillInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillInfo& operator=(SkillInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SkillInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SkillInfo* internal_default_instance() {
    return reinterpret_cast<const SkillInfo*>(
               &_SkillInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SkillInfo& a, SkillInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SkillInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SkillInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SkillInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SkillInfo& from) {
    SkillInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SkillInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SkillInfo";
  }
  protected:
  explicit SkillInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkillIdFieldNumber = 1,
  };
  // int32 skillId = 1;
  void clear_skillid();
  int32_t skillid() const;
  void set_skillid(int32_t value);
  private:
  int32_t _internal_skillid() const;
  void _internal_set_skillid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SkillInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t skillid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class ItemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ItemInfo) */ {
 public:
  inline ItemInfo() : ItemInfo(nullptr) {}
  ~ItemInfo() override;
  explicit PROTOBUF_CONSTEXPR ItemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemInfo(const ItemInfo& from);
  ItemInfo(ItemInfo&& from) noexcept
    : ItemInfo() {
    *this = ::std::move(from);
  }

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemInfo& operator=(ItemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemInfo* internal_default_instance() {
    return reinterpret_cast<const ItemInfo*>(
               &_ItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ItemInfo& a, ItemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemInfo& from) {
    ItemInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ItemInfo";
  }
  protected:
  explicit ItemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemDbIdFieldNumber = 1,
    kDataSheetIdFieldNumber = 2,
    kCountFieldNumber = 3,
    kSlotFieldNumber = 4,
    kEquippedFieldNumber = 5,
  };
  // int32 itemDbId = 1;
  void clear_itemdbid();
  int32_t itemdbid() const;
  void set_itemdbid(int32_t value);
  private:
  int32_t _internal_itemdbid() const;
  void _internal_set_itemdbid(int32_t value);
  public:

  // int32 dataSheetId = 2;
  void clear_datasheetid();
  int32_t datasheetid() const;
  void set_datasheetid(int32_t value);
  private:
  int32_t _internal_datasheetid() const;
  void _internal_set_datasheetid(int32_t value);
  public:

  // int32 count = 3;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // int32 slot = 4;
  void clear_slot();
  int32_t slot() const;
  void set_slot(int32_t value);
  private:
  int32_t _internal_slot() const;
  void _internal_set_slot(int32_t value);
  public:

  // bool equipped = 5;
  void clear_equipped();
  bool equipped() const;
  void set_equipped(bool value);
  private:
  bool _internal_equipped() const;
  void _internal_set_equipped(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ItemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t itemdbid_;
    int32_t datasheetid_;
    int32_t count_;
    int32_t slot_;
    bool equipped_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// S_EnterGame

// .Protocol.ObjectInfo player = 1;
inline bool S_EnterGame::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool S_EnterGame::has_player() const {
  return _internal_has_player();
}
inline void S_EnterGame::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::Protocol::ObjectInfo& S_EnterGame::_internal_player() const {
  const ::Protocol::ObjectInfo* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_EnterGame::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EnterGame.player)
  return _internal_player();
}
inline void S_EnterGame::unsafe_arena_set_allocated_player(
    ::Protocol::ObjectInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_EnterGame.player)
}
inline ::Protocol::ObjectInfo* S_EnterGame::release_player() {
  
  ::Protocol::ObjectInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_EnterGame::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_EnterGame.player)
  
  ::Protocol::ObjectInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_EnterGame::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::Protocol::ObjectInfo* S_EnterGame::mutable_player() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:Protocol.S_EnterGame.player)
  return _msg;
}
inline void S_EnterGame::set_allocated_player(::Protocol::ObjectInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_EnterGame.player)
}

// -------------------------------------------------------------------

// S_LeaveGame

// -------------------------------------------------------------------

// S_Spawn

// repeated .Protocol.ObjectInfo objects = 1;
inline int S_Spawn::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int S_Spawn::objects_size() const {
  return _internal_objects_size();
}
inline void S_Spawn::clear_objects() {
  _impl_.objects_.Clear();
}
inline ::Protocol::ObjectInfo* S_Spawn::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_Spawn.objects)
  return _impl_.objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
S_Spawn::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_Spawn.objects)
  return &_impl_.objects_;
}
inline const ::Protocol::ObjectInfo& S_Spawn::_internal_objects(int index) const {
  return _impl_.objects_.Get(index);
}
inline const ::Protocol::ObjectInfo& S_Spawn::objects(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_Spawn.objects)
  return _internal_objects(index);
}
inline ::Protocol::ObjectInfo* S_Spawn::_internal_add_objects() {
  return _impl_.objects_.Add();
}
inline ::Protocol::ObjectInfo* S_Spawn::add_objects() {
  ::Protocol::ObjectInfo* _add = _internal_add_objects();
  // @@protoc_insertion_point(field_add:Protocol.S_Spawn.objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
S_Spawn::objects() const {
  // @@protoc_insertion_point(field_list:Protocol.S_Spawn.objects)
  return _impl_.objects_;
}

// -------------------------------------------------------------------

// S_Despawn

// repeated int32 objectIds = 1;
inline int S_Despawn::_internal_objectids_size() const {
  return _impl_.objectids_.size();
}
inline int S_Despawn::objectids_size() const {
  return _internal_objectids_size();
}
inline void S_Despawn::clear_objectids() {
  _impl_.objectids_.Clear();
}
inline int32_t S_Despawn::_internal_objectids(int index) const {
  return _impl_.objectids_.Get(index);
}
inline int32_t S_Despawn::objectids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_Despawn.objectIds)
  return _internal_objectids(index);
}
inline void S_Despawn::set_objectids(int index, int32_t value) {
  _impl_.objectids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_Despawn.objectIds)
}
inline void S_Despawn::_internal_add_objectids(int32_t value) {
  _impl_.objectids_.Add(value);
}
inline void S_Despawn::add_objectids(int32_t value) {
  _internal_add_objectids(value);
  // @@protoc_insertion_point(field_add:Protocol.S_Despawn.objectIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_Despawn::_internal_objectids() const {
  return _impl_.objectids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_Despawn::objectids() const {
  // @@protoc_insertion_point(field_list:Protocol.S_Despawn.objectIds)
  return _internal_objectids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_Despawn::_internal_mutable_objectids() {
  return &_impl_.objectids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_Despawn::mutable_objectids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_Despawn.objectIds)
  return _internal_mutable_objectids();
}

// -------------------------------------------------------------------

// C_Move

// .Protocol.PositionInfo posInfo = 1;
inline bool C_Move::_internal_has_posinfo() const {
  return this != internal_default_instance() && _impl_.posinfo_ != nullptr;
}
inline bool C_Move::has_posinfo() const {
  return _internal_has_posinfo();
}
inline void C_Move::clear_posinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.posinfo_ != nullptr) {
    delete _impl_.posinfo_;
  }
  _impl_.posinfo_ = nullptr;
}
inline const ::Protocol::PositionInfo& C_Move::_internal_posinfo() const {
  const ::Protocol::PositionInfo* p = _impl_.posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& C_Move::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Move.posInfo)
  return _internal_posinfo();
}
inline void C_Move::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PositionInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posinfo_);
  }
  _impl_.posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_Move.posInfo)
}
inline ::Protocol::PositionInfo* C_Move::release_posinfo() {
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PositionInfo* C_Move::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_Move.posInfo)
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* C_Move::_internal_mutable_posinfo() {
  
  if (_impl_.posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    _impl_.posinfo_ = p;
  }
  return _impl_.posinfo_;
}
inline ::Protocol::PositionInfo* C_Move::mutable_posinfo() {
  ::Protocol::PositionInfo* _msg = _internal_mutable_posinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.C_Move.posInfo)
  return _msg;
}
inline void C_Move::set_allocated_posinfo(::Protocol::PositionInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.posinfo_;
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(posinfo);
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_Move.posInfo)
}

// -------------------------------------------------------------------

// S_Move

// int32 objectId = 1;
inline void S_Move::clear_objectid() {
  _impl_.objectid_ = 0;
}
inline int32_t S_Move::_internal_objectid() const {
  return _impl_.objectid_;
}
inline int32_t S_Move::objectid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Move.objectId)
  return _internal_objectid();
}
inline void S_Move::_internal_set_objectid(int32_t value) {
  
  _impl_.objectid_ = value;
}
inline void S_Move::set_objectid(int32_t value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Move.objectId)
}

// .Protocol.PositionInfo posInfo = 2;
inline bool S_Move::_internal_has_posinfo() const {
  return this != internal_default_instance() && _impl_.posinfo_ != nullptr;
}
inline bool S_Move::has_posinfo() const {
  return _internal_has_posinfo();
}
inline void S_Move::clear_posinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.posinfo_ != nullptr) {
    delete _impl_.posinfo_;
  }
  _impl_.posinfo_ = nullptr;
}
inline const ::Protocol::PositionInfo& S_Move::_internal_posinfo() const {
  const ::Protocol::PositionInfo* p = _impl_.posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& S_Move::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Move.posInfo)
  return _internal_posinfo();
}
inline void S_Move::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PositionInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posinfo_);
  }
  _impl_.posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_Move.posInfo)
}
inline ::Protocol::PositionInfo* S_Move::release_posinfo() {
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PositionInfo* S_Move::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_Move.posInfo)
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* S_Move::_internal_mutable_posinfo() {
  
  if (_impl_.posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    _impl_.posinfo_ = p;
  }
  return _impl_.posinfo_;
}
inline ::Protocol::PositionInfo* S_Move::mutable_posinfo() {
  ::Protocol::PositionInfo* _msg = _internal_mutable_posinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_Move.posInfo)
  return _msg;
}
inline void S_Move::set_allocated_posinfo(::Protocol::PositionInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.posinfo_;
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(posinfo);
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_Move.posInfo)
}

// -------------------------------------------------------------------

// C_Skill

// .Protocol.SkillInfo info = 1;
inline bool C_Skill::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool C_Skill::has_info() const {
  return _internal_has_info();
}
inline void C_Skill::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::Protocol::SkillInfo& C_Skill::_internal_info() const {
  const ::Protocol::SkillInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SkillInfo&>(
      ::Protocol::_SkillInfo_default_instance_);
}
inline const ::Protocol::SkillInfo& C_Skill::info() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Skill.info)
  return _internal_info();
}
inline void C_Skill::unsafe_arena_set_allocated_info(
    ::Protocol::SkillInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_Skill.info)
}
inline ::Protocol::SkillInfo* C_Skill::release_info() {
  
  ::Protocol::SkillInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::SkillInfo* C_Skill::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.C_Skill.info)
  
  ::Protocol::SkillInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::SkillInfo* C_Skill::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SkillInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::SkillInfo* C_Skill::mutable_info() {
  ::Protocol::SkillInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.C_Skill.info)
  return _msg;
}
inline void C_Skill::set_allocated_info(::Protocol::SkillInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_Skill.info)
}

// -------------------------------------------------------------------

// S_Skill

// int32 objectId = 1;
inline void S_Skill::clear_objectid() {
  _impl_.objectid_ = 0;
}
inline int32_t S_Skill::_internal_objectid() const {
  return _impl_.objectid_;
}
inline int32_t S_Skill::objectid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Skill.objectId)
  return _internal_objectid();
}
inline void S_Skill::_internal_set_objectid(int32_t value) {
  
  _impl_.objectid_ = value;
}
inline void S_Skill::set_objectid(int32_t value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Skill.objectId)
}

// .Protocol.SkillInfo info = 2;
inline bool S_Skill::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_Skill::has_info() const {
  return _internal_has_info();
}
inline void S_Skill::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::Protocol::SkillInfo& S_Skill::_internal_info() const {
  const ::Protocol::SkillInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SkillInfo&>(
      ::Protocol::_SkillInfo_default_instance_);
}
inline const ::Protocol::SkillInfo& S_Skill::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Skill.info)
  return _internal_info();
}
inline void S_Skill::unsafe_arena_set_allocated_info(
    ::Protocol::SkillInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_Skill.info)
}
inline ::Protocol::SkillInfo* S_Skill::release_info() {
  
  ::Protocol::SkillInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::SkillInfo* S_Skill::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_Skill.info)
  
  ::Protocol::SkillInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::SkillInfo* S_Skill::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SkillInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::SkillInfo* S_Skill::mutable_info() {
  ::Protocol::SkillInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_Skill.info)
  return _msg;
}
inline void S_Skill::set_allocated_info(::Protocol::SkillInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_Skill.info)
}

// -------------------------------------------------------------------

// S_ChangeHp

// int32 objectId = 1;
inline void S_ChangeHp::clear_objectid() {
  _impl_.objectid_ = 0;
}
inline int32_t S_ChangeHp::_internal_objectid() const {
  return _impl_.objectid_;
}
inline int32_t S_ChangeHp::objectid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeHp.objectId)
  return _internal_objectid();
}
inline void S_ChangeHp::_internal_set_objectid(int32_t value) {
  
  _impl_.objectid_ = value;
}
inline void S_ChangeHp::set_objectid(int32_t value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ChangeHp.objectId)
}

// int32 hp = 2;
inline void S_ChangeHp::clear_hp() {
  _impl_.hp_ = 0;
}
inline int32_t S_ChangeHp::_internal_hp() const {
  return _impl_.hp_;
}
inline int32_t S_ChangeHp::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeHp.hp)
  return _internal_hp();
}
inline void S_ChangeHp::_internal_set_hp(int32_t value) {
  
  _impl_.hp_ = value;
}
inline void S_ChangeHp::set_hp(int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ChangeHp.hp)
}

// -------------------------------------------------------------------

// S_Die

// int32 objectId = 1;
inline void S_Die::clear_objectid() {
  _impl_.objectid_ = 0;
}
inline int32_t S_Die::_internal_objectid() const {
  return _impl_.objectid_;
}
inline int32_t S_Die::objectid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Die.objectId)
  return _internal_objectid();
}
inline void S_Die::_internal_set_objectid(int32_t value) {
  
  _impl_.objectid_ = value;
}
inline void S_Die::set_objectid(int32_t value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Die.objectId)
}

// int32 attackerId = 2;
inline void S_Die::clear_attackerid() {
  _impl_.attackerid_ = 0;
}
inline int32_t S_Die::_internal_attackerid() const {
  return _impl_.attackerid_;
}
inline int32_t S_Die::attackerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Die.attackerId)
  return _internal_attackerid();
}
inline void S_Die::_internal_set_attackerid(int32_t value) {
  
  _impl_.attackerid_ = value;
}
inline void S_Die::set_attackerid(int32_t value) {
  _internal_set_attackerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Die.attackerId)
}

// -------------------------------------------------------------------

// S_Connected

// -------------------------------------------------------------------

// C_Login

// string uniqueId = 1;
inline void C_Login::clear_uniqueid() {
  _impl_.uniqueid_.ClearToEmpty();
}
inline const std::string& C_Login::uniqueid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Login.uniqueId)
  return _internal_uniqueid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_Login::set_uniqueid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uniqueid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_Login.uniqueId)
}
inline std::string* C_Login::mutable_uniqueid() {
  std::string* _s = _internal_mutable_uniqueid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_Login.uniqueId)
  return _s;
}
inline const std::string& C_Login::_internal_uniqueid() const {
  return _impl_.uniqueid_.Get();
}
inline void C_Login::_internal_set_uniqueid(const std::string& value) {
  
  _impl_.uniqueid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_Login::_internal_mutable_uniqueid() {
  
  return _impl_.uniqueid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_Login::release_uniqueid() {
  // @@protoc_insertion_point(field_release:Protocol.C_Login.uniqueId)
  return _impl_.uniqueid_.Release();
}
inline void C_Login::set_allocated_uniqueid(std::string* uniqueid) {
  if (uniqueid != nullptr) {
    
  } else {
    
  }
  _impl_.uniqueid_.SetAllocated(uniqueid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uniqueid_.IsDefault()) {
    _impl_.uniqueid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_Login.uniqueId)
}

// -------------------------------------------------------------------

// S_Login

// int32 loginOk = 1;
inline void S_Login::clear_loginok() {
  _impl_.loginok_ = 0;
}
inline int32_t S_Login::_internal_loginok() const {
  return _impl_.loginok_;
}
inline int32_t S_Login::loginok() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Login.loginOk)
  return _internal_loginok();
}
inline void S_Login::_internal_set_loginok(int32_t value) {
  
  _impl_.loginok_ = value;
}
inline void S_Login::set_loginok(int32_t value) {
  _internal_set_loginok(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Login.loginOk)
}

// repeated .Protocol.LobbyPlayerInfo players = 2;
inline int S_Login::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int S_Login::players_size() const {
  return _internal_players_size();
}
inline void S_Login::clear_players() {
  _impl_.players_.Clear();
}
inline ::Protocol::LobbyPlayerInfo* S_Login::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_Login.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo >*
S_Login::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_Login.players)
  return &_impl_.players_;
}
inline const ::Protocol::LobbyPlayerInfo& S_Login::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::LobbyPlayerInfo& S_Login::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_Login.players)
  return _internal_players(index);
}
inline ::Protocol::LobbyPlayerInfo* S_Login::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::LobbyPlayerInfo* S_Login::add_players() {
  ::Protocol::LobbyPlayerInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.S_Login.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo >&
S_Login::players() const {
  // @@protoc_insertion_point(field_list:Protocol.S_Login.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// C_EnterGame

// string name = 1;
inline void C_EnterGame::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& C_EnterGame::name() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EnterGame.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_EnterGame::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_EnterGame.name)
}
inline std::string* C_EnterGame::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.C_EnterGame.name)
  return _s;
}
inline const std::string& C_EnterGame::_internal_name() const {
  return _impl_.name_.Get();
}
inline void C_EnterGame::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* C_EnterGame::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* C_EnterGame::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.C_EnterGame.name)
  return _impl_.name_.Release();
}
inline void C_EnterGame::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_EnterGame.name)
}

// -------------------------------------------------------------------

// S_CreatePlayer

// .Protocol.LobbyPlayerInfo player = 1;
inline bool S_CreatePlayer::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool S_CreatePlayer::has_player() const {
  return _internal_has_player();
}
inline void S_CreatePlayer::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::Protocol::LobbyPlayerInfo& S_CreatePlayer::_internal_player() const {
  const ::Protocol::LobbyPlayerInfo* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::LobbyPlayerInfo&>(
      ::Protocol::_LobbyPlayerInfo_default_instance_);
}
inline const ::Protocol::LobbyPlayerInfo& S_CreatePlayer::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CreatePlayer.player)
  return _internal_player();
}
inline void S_CreatePlayer::unsafe_arena_set_allocated_player(
    ::Protocol::LobbyPlayerInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_CreatePlayer.player)
}
inline ::Protocol::LobbyPlayerInfo* S_CreatePlayer::release_player() {
  
  ::Protocol::LobbyPlayerInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::LobbyPlayerInfo* S_CreatePlayer::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_CreatePlayer.player)
  
  ::Protocol::LobbyPlayerInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::Protocol::LobbyPlayerInfo* S_CreatePlayer::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::LobbyPlayerInfo>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::Protocol::LobbyPlayerInfo* S_CreatePlayer::mutable_player() {
  ::Protocol::LobbyPlayerInfo* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CreatePlayer.player)
  return _msg;
}
inline void S_CreatePlayer::set_allocated_player(::Protocol::LobbyPlayerInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CreatePlayer.player)
}

// -------------------------------------------------------------------

// C_CreatePlayer

// string name = 1;
inline void C_CreatePlayer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& C_CreatePlayer::name() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CreatePlayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CreatePlayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CreatePlayer.name)
}
inline std::string* C_CreatePlayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CreatePlayer.name)
  return _s;
}
inline const std::string& C_CreatePlayer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void C_CreatePlayer::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CreatePlayer::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CreatePlayer::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.C_CreatePlayer.name)
  return _impl_.name_.Release();
}
inline void C_CreatePlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CreatePlayer.name)
}

// -------------------------------------------------------------------

// S_ItemList

// repeated .Protocol.ItemInfo items = 1;
inline int S_ItemList::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int S_ItemList::items_size() const {
  return _internal_items_size();
}
inline void S_ItemList::clear_items() {
  _impl_.items_.Clear();
}
inline ::Protocol::ItemInfo* S_ItemList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_ItemList.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
S_ItemList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_ItemList.items)
  return &_impl_.items_;
}
inline const ::Protocol::ItemInfo& S_ItemList::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::Protocol::ItemInfo& S_ItemList::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_ItemList.items)
  return _internal_items(index);
}
inline ::Protocol::ItemInfo* S_ItemList::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::Protocol::ItemInfo* S_ItemList::add_items() {
  ::Protocol::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.S_ItemList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
S_ItemList::items() const {
  // @@protoc_insertion_point(field_list:Protocol.S_ItemList.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// S_AddItem

// repeated .Protocol.ItemInfo items = 1;
inline int S_AddItem::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int S_AddItem::items_size() const {
  return _internal_items_size();
}
inline void S_AddItem::clear_items() {
  _impl_.items_.Clear();
}
inline ::Protocol::ItemInfo* S_AddItem::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_AddItem.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
S_AddItem::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_AddItem.items)
  return &_impl_.items_;
}
inline const ::Protocol::ItemInfo& S_AddItem::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::Protocol::ItemInfo& S_AddItem::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_AddItem.items)
  return _internal_items(index);
}
inline ::Protocol::ItemInfo* S_AddItem::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::Protocol::ItemInfo* S_AddItem::add_items() {
  ::Protocol::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.S_AddItem.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
S_AddItem::items() const {
  // @@protoc_insertion_point(field_list:Protocol.S_AddItem.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// C_EquipItem

// int32 slot = 1;
inline void C_EquipItem::clear_slot() {
  _impl_.slot_ = 0;
}
inline int32_t C_EquipItem::_internal_slot() const {
  return _impl_.slot_;
}
inline int32_t C_EquipItem::slot() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EquipItem.slot)
  return _internal_slot();
}
inline void C_EquipItem::_internal_set_slot(int32_t value) {
  
  _impl_.slot_ = value;
}
inline void C_EquipItem::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EquipItem.slot)
}

// bool equipped = 2;
inline void C_EquipItem::clear_equipped() {
  _impl_.equipped_ = false;
}
inline bool C_EquipItem::_internal_equipped() const {
  return _impl_.equipped_;
}
inline bool C_EquipItem::equipped() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EquipItem.equipped)
  return _internal_equipped();
}
inline void C_EquipItem::_internal_set_equipped(bool value) {
  
  _impl_.equipped_ = value;
}
inline void C_EquipItem::set_equipped(bool value) {
  _internal_set_equipped(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EquipItem.equipped)
}

// -------------------------------------------------------------------

// S_EquipItem

// int32 slot = 1;
inline void S_EquipItem::clear_slot() {
  _impl_.slot_ = 0;
}
inline int32_t S_EquipItem::_internal_slot() const {
  return _impl_.slot_;
}
inline int32_t S_EquipItem::slot() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EquipItem.slot)
  return _internal_slot();
}
inline void S_EquipItem::_internal_set_slot(int32_t value) {
  
  _impl_.slot_ = value;
}
inline void S_EquipItem::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EquipItem.slot)
}

// bool equipped = 2;
inline void S_EquipItem::clear_equipped() {
  _impl_.equipped_ = false;
}
inline bool S_EquipItem::_internal_equipped() const {
  return _impl_.equipped_;
}
inline bool S_EquipItem::equipped() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EquipItem.equipped)
  return _internal_equipped();
}
inline void S_EquipItem::_internal_set_equipped(bool value) {
  
  _impl_.equipped_ = value;
}
inline void S_EquipItem::set_equipped(bool value) {
  _internal_set_equipped(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EquipItem.equipped)
}

// -------------------------------------------------------------------

// C_UseItem

// int32 slot = 1;
inline void C_UseItem::clear_slot() {
  _impl_.slot_ = 0;
}
inline int32_t C_UseItem::_internal_slot() const {
  return _impl_.slot_;
}
inline int32_t C_UseItem::slot() const {
  // @@protoc_insertion_point(field_get:Protocol.C_UseItem.slot)
  return _internal_slot();
}
inline void C_UseItem::_internal_set_slot(int32_t value) {
  
  _impl_.slot_ = value;
}
inline void C_UseItem::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:Protocol.C_UseItem.slot)
}

// -------------------------------------------------------------------

// S_UseItem

// int32 slot = 1;
inline void S_UseItem::clear_slot() {
  _impl_.slot_ = 0;
}
inline int32_t S_UseItem::_internal_slot() const {
  return _impl_.slot_;
}
inline int32_t S_UseItem::slot() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UseItem.slot)
  return _internal_slot();
}
inline void S_UseItem::_internal_set_slot(int32_t value) {
  
  _impl_.slot_ = value;
}
inline void S_UseItem::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UseItem.slot)
}

// -------------------------------------------------------------------

// S_ChangeStat

// .Protocol.StatInfo statInfo = 1;
inline bool S_ChangeStat::_internal_has_statinfo() const {
  return this != internal_default_instance() && _impl_.statinfo_ != nullptr;
}
inline bool S_ChangeStat::has_statinfo() const {
  return _internal_has_statinfo();
}
inline void S_ChangeStat::clear_statinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.statinfo_ != nullptr) {
    delete _impl_.statinfo_;
  }
  _impl_.statinfo_ = nullptr;
}
inline const ::Protocol::StatInfo& S_ChangeStat::_internal_statinfo() const {
  const ::Protocol::StatInfo* p = _impl_.statinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatInfo&>(
      ::Protocol::_StatInfo_default_instance_);
}
inline const ::Protocol::StatInfo& S_ChangeStat::statinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeStat.statInfo)
  return _internal_statinfo();
}
inline void S_ChangeStat::unsafe_arena_set_allocated_statinfo(
    ::Protocol::StatInfo* statinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statinfo_);
  }
  _impl_.statinfo_ = statinfo;
  if (statinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ChangeStat.statInfo)
}
inline ::Protocol::StatInfo* S_ChangeStat::release_statinfo() {
  
  ::Protocol::StatInfo* temp = _impl_.statinfo_;
  _impl_.statinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::StatInfo* S_ChangeStat::unsafe_arena_release_statinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_ChangeStat.statInfo)
  
  ::Protocol::StatInfo* temp = _impl_.statinfo_;
  _impl_.statinfo_ = nullptr;
  return temp;
}
inline ::Protocol::StatInfo* S_ChangeStat::_internal_mutable_statinfo() {
  
  if (_impl_.statinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatInfo>(GetArenaForAllocation());
    _impl_.statinfo_ = p;
  }
  return _impl_.statinfo_;
}
inline ::Protocol::StatInfo* S_ChangeStat::mutable_statinfo() {
  ::Protocol::StatInfo* _msg = _internal_mutable_statinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ChangeStat.statInfo)
  return _msg;
}
inline void S_ChangeStat::set_allocated_statinfo(::Protocol::StatInfo* statinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.statinfo_;
  }
  if (statinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(statinfo);
    if (message_arena != submessage_arena) {
      statinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.statinfo_ = statinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ChangeStat.statInfo)
}

// -------------------------------------------------------------------

// S_Ping

// -------------------------------------------------------------------

// C_Pong

// -------------------------------------------------------------------

// ObjectInfo

// int32 objectId = 1;
inline void ObjectInfo::clear_objectid() {
  _impl_.objectid_ = 0;
}
inline int32_t ObjectInfo::_internal_objectid() const {
  return _impl_.objectid_;
}
inline int32_t ObjectInfo::objectid() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectInfo.objectId)
  return _internal_objectid();
}
inline void ObjectInfo::_internal_set_objectid(int32_t value) {
  
  _impl_.objectid_ = value;
}
inline void ObjectInfo::set_objectid(int32_t value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:Protocol.ObjectInfo.objectId)
}

// string name = 2;
inline void ObjectInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ObjectInfo::name() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.ObjectInfo.name)
}
inline std::string* ObjectInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.ObjectInfo.name)
  return _s;
}
inline const std::string& ObjectInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ObjectInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectInfo::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.ObjectInfo.name)
  return _impl_.name_.Release();
}
inline void ObjectInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.ObjectInfo.name)
}

// .Protocol.PositionInfo posInfo = 3;
inline bool ObjectInfo::_internal_has_posinfo() const {
  return this != internal_default_instance() && _impl_.posinfo_ != nullptr;
}
inline bool ObjectInfo::has_posinfo() const {
  return _internal_has_posinfo();
}
inline void ObjectInfo::clear_posinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.posinfo_ != nullptr) {
    delete _impl_.posinfo_;
  }
  _impl_.posinfo_ = nullptr;
}
inline const ::Protocol::PositionInfo& ObjectInfo::_internal_posinfo() const {
  const ::Protocol::PositionInfo* p = _impl_.posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& ObjectInfo::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectInfo.posInfo)
  return _internal_posinfo();
}
inline void ObjectInfo::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PositionInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posinfo_);
  }
  _impl_.posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ObjectInfo.posInfo)
}
inline ::Protocol::PositionInfo* ObjectInfo::release_posinfo() {
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PositionInfo* ObjectInfo::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.ObjectInfo.posInfo)
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* ObjectInfo::_internal_mutable_posinfo() {
  
  if (_impl_.posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    _impl_.posinfo_ = p;
  }
  return _impl_.posinfo_;
}
inline ::Protocol::PositionInfo* ObjectInfo::mutable_posinfo() {
  ::Protocol::PositionInfo* _msg = _internal_mutable_posinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.ObjectInfo.posInfo)
  return _msg;
}
inline void ObjectInfo::set_allocated_posinfo(::Protocol::PositionInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.posinfo_;
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(posinfo);
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ObjectInfo.posInfo)
}

// .Protocol.StatInfo statInfo = 4;
inline bool ObjectInfo::_internal_has_statinfo() const {
  return this != internal_default_instance() && _impl_.statinfo_ != nullptr;
}
inline bool ObjectInfo::has_statinfo() const {
  return _internal_has_statinfo();
}
inline void ObjectInfo::clear_statinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.statinfo_ != nullptr) {
    delete _impl_.statinfo_;
  }
  _impl_.statinfo_ = nullptr;
}
inline const ::Protocol::StatInfo& ObjectInfo::_internal_statinfo() const {
  const ::Protocol::StatInfo* p = _impl_.statinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatInfo&>(
      ::Protocol::_StatInfo_default_instance_);
}
inline const ::Protocol::StatInfo& ObjectInfo::statinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.ObjectInfo.statInfo)
  return _internal_statinfo();
}
inline void ObjectInfo::unsafe_arena_set_allocated_statinfo(
    ::Protocol::StatInfo* statinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statinfo_);
  }
  _impl_.statinfo_ = statinfo;
  if (statinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ObjectInfo.statInfo)
}
inline ::Protocol::StatInfo* ObjectInfo::release_statinfo() {
  
  ::Protocol::StatInfo* temp = _impl_.statinfo_;
  _impl_.statinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::StatInfo* ObjectInfo::unsafe_arena_release_statinfo() {
  // @@protoc_insertion_point(field_release:Protocol.ObjectInfo.statInfo)
  
  ::Protocol::StatInfo* temp = _impl_.statinfo_;
  _impl_.statinfo_ = nullptr;
  return temp;
}
inline ::Protocol::StatInfo* ObjectInfo::_internal_mutable_statinfo() {
  
  if (_impl_.statinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatInfo>(GetArenaForAllocation());
    _impl_.statinfo_ = p;
  }
  return _impl_.statinfo_;
}
inline ::Protocol::StatInfo* ObjectInfo::mutable_statinfo() {
  ::Protocol::StatInfo* _msg = _internal_mutable_statinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.ObjectInfo.statInfo)
  return _msg;
}
inline void ObjectInfo::set_allocated_statinfo(::Protocol::StatInfo* statinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.statinfo_;
  }
  if (statinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(statinfo);
    if (message_arena != submessage_arena) {
      statinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.statinfo_ = statinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ObjectInfo.statInfo)
}

// -------------------------------------------------------------------

// LobbyPlayerInfo

// int32 playerDbId = 1;
inline void LobbyPlayerInfo::clear_playerdbid() {
  _impl_.playerdbid_ = 0;
}
inline int32_t LobbyPlayerInfo::_internal_playerdbid() const {
  return _impl_.playerdbid_;
}
inline int32_t LobbyPlayerInfo::playerdbid() const {
  // @@protoc_insertion_point(field_get:Protocol.LobbyPlayerInfo.playerDbId)
  return _internal_playerdbid();
}
inline void LobbyPlayerInfo::_internal_set_playerdbid(int32_t value) {
  
  _impl_.playerdbid_ = value;
}
inline void LobbyPlayerInfo::set_playerdbid(int32_t value) {
  _internal_set_playerdbid(value);
  // @@protoc_insertion_point(field_set:Protocol.LobbyPlayerInfo.playerDbId)
}

// string name = 2;
inline void LobbyPlayerInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LobbyPlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:Protocol.LobbyPlayerInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LobbyPlayerInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.LobbyPlayerInfo.name)
}
inline std::string* LobbyPlayerInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.LobbyPlayerInfo.name)
  return _s;
}
inline const std::string& LobbyPlayerInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LobbyPlayerInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LobbyPlayerInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LobbyPlayerInfo::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.LobbyPlayerInfo.name)
  return _impl_.name_.Release();
}
inline void LobbyPlayerInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.LobbyPlayerInfo.name)
}

// .Protocol.StatInfo statInfo = 3;
inline bool LobbyPlayerInfo::_internal_has_statinfo() const {
  return this != internal_default_instance() && _impl_.statinfo_ != nullptr;
}
inline bool LobbyPlayerInfo::has_statinfo() const {
  return _internal_has_statinfo();
}
inline void LobbyPlayerInfo::clear_statinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.statinfo_ != nullptr) {
    delete _impl_.statinfo_;
  }
  _impl_.statinfo_ = nullptr;
}
inline const ::Protocol::StatInfo& LobbyPlayerInfo::_internal_statinfo() const {
  const ::Protocol::StatInfo* p = _impl_.statinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatInfo&>(
      ::Protocol::_StatInfo_default_instance_);
}
inline const ::Protocol::StatInfo& LobbyPlayerInfo::statinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.LobbyPlayerInfo.statInfo)
  return _internal_statinfo();
}
inline void LobbyPlayerInfo::unsafe_arena_set_allocated_statinfo(
    ::Protocol::StatInfo* statinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statinfo_);
  }
  _impl_.statinfo_ = statinfo;
  if (statinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.LobbyPlayerInfo.statInfo)
}
inline ::Protocol::StatInfo* LobbyPlayerInfo::release_statinfo() {
  
  ::Protocol::StatInfo* temp = _impl_.statinfo_;
  _impl_.statinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::StatInfo* LobbyPlayerInfo::unsafe_arena_release_statinfo() {
  // @@protoc_insertion_point(field_release:Protocol.LobbyPlayerInfo.statInfo)
  
  ::Protocol::StatInfo* temp = _impl_.statinfo_;
  _impl_.statinfo_ = nullptr;
  return temp;
}
inline ::Protocol::StatInfo* LobbyPlayerInfo::_internal_mutable_statinfo() {
  
  if (_impl_.statinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatInfo>(GetArenaForAllocation());
    _impl_.statinfo_ = p;
  }
  return _impl_.statinfo_;
}
inline ::Protocol::StatInfo* LobbyPlayerInfo::mutable_statinfo() {
  ::Protocol::StatInfo* _msg = _internal_mutable_statinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.LobbyPlayerInfo.statInfo)
  return _msg;
}
inline void LobbyPlayerInfo::set_allocated_statinfo(::Protocol::StatInfo* statinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.statinfo_;
  }
  if (statinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(statinfo);
    if (message_arena != submessage_arena) {
      statinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.statinfo_ = statinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.LobbyPlayerInfo.statInfo)
}

// -------------------------------------------------------------------

// PositionInfo

// .Protocol.EntityState state = 1;
inline void PositionInfo::clear_state() {
  _impl_.state_ = 0;
}
inline ::Protocol::EntityState PositionInfo::_internal_state() const {
  return static_cast< ::Protocol::EntityState >(_impl_.state_);
}
inline ::Protocol::EntityState PositionInfo::state() const {
  // @@protoc_insertion_point(field_get:Protocol.PositionInfo.state)
  return _internal_state();
}
inline void PositionInfo::_internal_set_state(::Protocol::EntityState value) {
  
  _impl_.state_ = value;
}
inline void PositionInfo::set_state(::Protocol::EntityState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Protocol.PositionInfo.state)
}

// .Protocol.MoveDir moveDir = 2;
inline void PositionInfo::clear_movedir() {
  _impl_.movedir_ = 0;
}
inline ::Protocol::MoveDir PositionInfo::_internal_movedir() const {
  return static_cast< ::Protocol::MoveDir >(_impl_.movedir_);
}
inline ::Protocol::MoveDir PositionInfo::movedir() const {
  // @@protoc_insertion_point(field_get:Protocol.PositionInfo.moveDir)
  return _internal_movedir();
}
inline void PositionInfo::_internal_set_movedir(::Protocol::MoveDir value) {
  
  _impl_.movedir_ = value;
}
inline void PositionInfo::set_movedir(::Protocol::MoveDir value) {
  _internal_set_movedir(value);
  // @@protoc_insertion_point(field_set:Protocol.PositionInfo.moveDir)
}

// int32 PosX = 3;
inline void PositionInfo::clear_posx() {
  _impl_.posx_ = 0;
}
inline int32_t PositionInfo::_internal_posx() const {
  return _impl_.posx_;
}
inline int32_t PositionInfo::posx() const {
  // @@protoc_insertion_point(field_get:Protocol.PositionInfo.PosX)
  return _internal_posx();
}
inline void PositionInfo::_internal_set_posx(int32_t value) {
  
  _impl_.posx_ = value;
}
inline void PositionInfo::set_posx(int32_t value) {
  _internal_set_posx(value);
  // @@protoc_insertion_point(field_set:Protocol.PositionInfo.PosX)
}

// int32 PosY = 4;
inline void PositionInfo::clear_posy() {
  _impl_.posy_ = 0;
}
inline int32_t PositionInfo::_internal_posy() const {
  return _impl_.posy_;
}
inline int32_t PositionInfo::posy() const {
  // @@protoc_insertion_point(field_get:Protocol.PositionInfo.PosY)
  return _internal_posy();
}
inline void PositionInfo::_internal_set_posy(int32_t value) {
  
  _impl_.posy_ = value;
}
inline void PositionInfo::set_posy(int32_t value) {
  _internal_set_posy(value);
  // @@protoc_insertion_point(field_set:Protocol.PositionInfo.PosY)
}

// -------------------------------------------------------------------

// StatInfo

// int32 level = 1;
inline void StatInfo::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t StatInfo::_internal_level() const {
  return _impl_.level_;
}
inline int32_t StatInfo::level() const {
  // @@protoc_insertion_point(field_get:Protocol.StatInfo.level)
  return _internal_level();
}
inline void StatInfo::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void StatInfo::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.StatInfo.level)
}

// int32 hp = 2;
inline void StatInfo::clear_hp() {
  _impl_.hp_ = 0;
}
inline int32_t StatInfo::_internal_hp() const {
  return _impl_.hp_;
}
inline int32_t StatInfo::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.StatInfo.hp)
  return _internal_hp();
}
inline void StatInfo::_internal_set_hp(int32_t value) {
  
  _impl_.hp_ = value;
}
inline void StatInfo::set_hp(int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.StatInfo.hp)
}

// int32 maxHp = 3;
inline void StatInfo::clear_maxhp() {
  _impl_.maxhp_ = 0;
}
inline int32_t StatInfo::_internal_maxhp() const {
  return _impl_.maxhp_;
}
inline int32_t StatInfo::maxhp() const {
  // @@protoc_insertion_point(field_get:Protocol.StatInfo.maxHp)
  return _internal_maxhp();
}
inline void StatInfo::_internal_set_maxhp(int32_t value) {
  
  _impl_.maxhp_ = value;
}
inline void StatInfo::set_maxhp(int32_t value) {
  _internal_set_maxhp(value);
  // @@protoc_insertion_point(field_set:Protocol.StatInfo.maxHp)
}

// int32 attack = 4;
inline void StatInfo::clear_attack() {
  _impl_.attack_ = 0;
}
inline int32_t StatInfo::_internal_attack() const {
  return _impl_.attack_;
}
inline int32_t StatInfo::attack() const {
  // @@protoc_insertion_point(field_get:Protocol.StatInfo.attack)
  return _internal_attack();
}
inline void StatInfo::_internal_set_attack(int32_t value) {
  
  _impl_.attack_ = value;
}
inline void StatInfo::set_attack(int32_t value) {
  _internal_set_attack(value);
  // @@protoc_insertion_point(field_set:Protocol.StatInfo.attack)
}

// float speed = 5;
inline void StatInfo::clear_speed() {
  _impl_.speed_ = 0;
}
inline float StatInfo::_internal_speed() const {
  return _impl_.speed_;
}
inline float StatInfo::speed() const {
  // @@protoc_insertion_point(field_get:Protocol.StatInfo.speed)
  return _internal_speed();
}
inline void StatInfo::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void StatInfo::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:Protocol.StatInfo.speed)
}

// int32 totalExp = 6;
inline void StatInfo::clear_totalexp() {
  _impl_.totalexp_ = 0;
}
inline int32_t StatInfo::_internal_totalexp() const {
  return _impl_.totalexp_;
}
inline int32_t StatInfo::totalexp() const {
  // @@protoc_insertion_point(field_get:Protocol.StatInfo.totalExp)
  return _internal_totalexp();
}
inline void StatInfo::_internal_set_totalexp(int32_t value) {
  
  _impl_.totalexp_ = value;
}
inline void StatInfo::set_totalexp(int32_t value) {
  _internal_set_totalexp(value);
  // @@protoc_insertion_point(field_set:Protocol.StatInfo.totalExp)
}

// -------------------------------------------------------------------

// SkillInfo

// int32 skillId = 1;
inline void SkillInfo::clear_skillid() {
  _impl_.skillid_ = 0;
}
inline int32_t SkillInfo::_internal_skillid() const {
  return _impl_.skillid_;
}
inline int32_t SkillInfo::skillid() const {
  // @@protoc_insertion_point(field_get:Protocol.SkillInfo.skillId)
  return _internal_skillid();
}
inline void SkillInfo::_internal_set_skillid(int32_t value) {
  
  _impl_.skillid_ = value;
}
inline void SkillInfo::set_skillid(int32_t value) {
  _internal_set_skillid(value);
  // @@protoc_insertion_point(field_set:Protocol.SkillInfo.skillId)
}

// -------------------------------------------------------------------

// ItemInfo

// int32 itemDbId = 1;
inline void ItemInfo::clear_itemdbid() {
  _impl_.itemdbid_ = 0;
}
inline int32_t ItemInfo::_internal_itemdbid() const {
  return _impl_.itemdbid_;
}
inline int32_t ItemInfo::itemdbid() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.itemDbId)
  return _internal_itemdbid();
}
inline void ItemInfo::_internal_set_itemdbid(int32_t value) {
  
  _impl_.itemdbid_ = value;
}
inline void ItemInfo::set_itemdbid(int32_t value) {
  _internal_set_itemdbid(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.itemDbId)
}

// int32 dataSheetId = 2;
inline void ItemInfo::clear_datasheetid() {
  _impl_.datasheetid_ = 0;
}
inline int32_t ItemInfo::_internal_datasheetid() const {
  return _impl_.datasheetid_;
}
inline int32_t ItemInfo::datasheetid() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.dataSheetId)
  return _internal_datasheetid();
}
inline void ItemInfo::_internal_set_datasheetid(int32_t value) {
  
  _impl_.datasheetid_ = value;
}
inline void ItemInfo::set_datasheetid(int32_t value) {
  _internal_set_datasheetid(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.dataSheetId)
}

// int32 count = 3;
inline void ItemInfo::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t ItemInfo::_internal_count() const {
  return _impl_.count_;
}
inline int32_t ItemInfo::count() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.count)
  return _internal_count();
}
inline void ItemInfo::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void ItemInfo::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.count)
}

// int32 slot = 4;
inline void ItemInfo::clear_slot() {
  _impl_.slot_ = 0;
}
inline int32_t ItemInfo::_internal_slot() const {
  return _impl_.slot_;
}
inline int32_t ItemInfo::slot() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.slot)
  return _internal_slot();
}
inline void ItemInfo::_internal_set_slot(int32_t value) {
  
  _impl_.slot_ = value;
}
inline void ItemInfo::set_slot(int32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.slot)
}

// bool equipped = 5;
inline void ItemInfo::clear_equipped() {
  _impl_.equipped_ = false;
}
inline bool ItemInfo::_internal_equipped() const {
  return _impl_.equipped_;
}
inline bool ItemInfo::equipped() const {
  // @@protoc_insertion_point(field_get:Protocol.ItemInfo.equipped)
  return _internal_equipped();
}
inline void ItemInfo::_internal_set_equipped(bool value) {
  
  _impl_.equipped_ = value;
}
inline void ItemInfo::set_equipped(bool value) {
  _internal_set_equipped(value);
  // @@protoc_insertion_point(field_set:Protocol.ItemInfo.equipped)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Protocol::MessageId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::MessageId>() {
  return ::Protocol::MessageId_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EntityState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EntityState>() {
  return ::Protocol::EntityState_descriptor();
}
template <> struct is_proto_enum< ::Protocol::MoveDir> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::MoveDir>() {
  return ::Protocol::MoveDir_descriptor();
}
template <> struct is_proto_enum< ::Protocol::GameObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::GameObjectType>() {
  return ::Protocol::GameObjectType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::SkillType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::SkillType>() {
  return ::Protocol::SkillType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::PlayerServerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::PlayerServerState>() {
  return ::Protocol::PlayerServerState_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ItemType>() {
  return ::Protocol::ItemType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::WeaponType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::WeaponType>() {
  return ::Protocol::WeaponType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ArmorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ArmorType>() {
  return ::Protocol::ArmorType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ConsumableType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ConsumableType>() {
  return ::Protocol::ConsumableType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
