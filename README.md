# MMORPG Game Server

## 목표

- 모던 C++로 제작하는 **2D MMORPG** 게임 서버
- 멀티스레드
- 유니티 클라이언트와 연동
- 패킷 처리 DB 저장 등의 비동기 처리
- 이동, 스킬 사용 동기화
- 인벤토리 사용

## 서버 코어

### 읽기 락/쓰기 락 구현

#### 기본 구현 기술
- C++ 표준의 **cas** 함수를 활용한 스핀 락
  - `atom` 클래스의 `compare_exchange_weak(x)` 함수 활용

#### 읽기 락 정책
- **쓰기 락을 잡고 있지 않는 모든 스레드**는 포괄적으로 읽기 락을 획득한다
- 쓰기 락을 잡은 동일 스레드만 읽기 락을 획득할 수 있다
- [쓰기 락 → 읽기 락]은 허용된다

#### 쓰기 락 정책
- 쓰기 락은 동일 스레드에 한해서만 **재귀적으로** 락을 획득한다
- 쓰기 락을 획득하면 다른 스레드가 쓰기 락을 획득할 수 없다
- 락 플래그가 **EMPTY** 상태일 때만 쓰기 락을 획득할 수 있다
- **[읽기 락 → 쓰기 락]** 은 허용되지 않는다

### 데드락 탐지
- 락 요청 그래프와 락 소유 그래프를 통해 사이클을 탐지한다
  - 스레드 **T1**이 **R1**을 보유하고 **R2**을 요청한다
  - 스레드 **T2**이 **R2**을 보유하고 R1을 요청한다
  - **R1 → T1 → R2 → T2 → R1 사이클 생성**
- 락을 획득하기 전에 **사이클 검사**를 수행한다
- 동일 스레드 기준 재귀 획득이 가능하기 때문에 횟수를 카운트한다

### 메모리 풀링
- 모든 크기에 대한 풀링을 하지 않고 32, 64, 96... 4096 크기까지 풀링 사이즈를 미리 정한다
- **1 ~ 32byte 요청 &nbsp;&nbsp;→ 32byte 메모리 풀링**
- **33 ~ 64byte 요청  → 64byte 메모리 풀링**
- 외부 단편화를 최소화하며 작은 크기의 잦은 메모리 할당/해제 오버헤드를 제거한다

#### 락프리 스택으로 메모리 관리
- 윈도우에서 제공하는 락 프리 스택 **API**인 **SLIST**를 사용해 메모리를 풀링한다.
- 해당 기능은 메모리를 **16 바이트**로 정렬해야 하기 때문에 관리 메모리를 C++ 표준인 `alignas(x)` 함수를 사용해 16 바이트로 정렬한다.

### 오브젝트 풀링
- 클래스(타입) 단위로 메모리 풀링을 할 필요가 있을 때는 오브젝트 풀링을 한다
- 메모리 풀링을 **랩핑(wrapping)** 해 사용하기 때문에 많은 상황에서 오브젝트 풀링이 사용된다.

### StompAllocator
- `VirtualAlloc` 등 **윈도우 API**를 사용해 **use-after-free** 문제와 오버플로우를 감지한다
  - `new`와 `delete`으로 메모리를 할당받고 해제할 경우 메모리가 힙 매니저에게 반환되고,
  - OS에 바로 언매핑 요청을 하지 않고 자유 리스트에 추가하디 때문에 메모리 위반을 검출이 어렵다.
  - 디버그 단계에서 _STOMP 매크로를 통해 적용하고 _STOMP를 적용하지 않으면 메모리 풀링이 적용된다

### StlAllocator
- 표준으로 제공되는 STL Container에 StlAllocator를 넣은 커스텀 STL을 사용한다.
- StlAllocator에서 메모리 할당과 해제에 메모리 풀링이 사용되기 때문에 메모리 할당과 해제로 인한 오버헤드를 줄일 수 있다.

### 잡큐
- 반응성을 높이기 위해 락을 사용하지 않고 일감을 큐에서 순차 처리한다
- 지금 프로젝트에서는 맵에서의 패킷 처리를 Room 객체에서 처리한다
- 잡큐를 활용해 모든 처리를 비동기적으로 처리하며 DB 전용 클래스를 통해 데이터를 비동기적으로 저장한다
  - DBSerializer
- 일감을 만들 때는 멤버 함수를 인수로 넘길 수도 있고 람다 함수 안에 로직으로 넘길 수도 있다

## 사용자 검증
### 웹 프로젝트
**백엔드: Spring Boot + Spring Security + JPA + Postgresql + JJWT**  
**프론트엔드: Next.js + Typescript + Axios + Formik + React-Query + Recoil + React-Toastify**

#### 흐름
1. 사용자가 사이트에서 로그인에 성공하면 서버가 클라이언트에게 액세스 토큰을 발급한다.
    - 백엔드 프로젝트에서 **jjwt** 라이브러리를 사용해 토큰을 발급하고 검증한다.
2. 웹에서 플레이 버튼을 누르면 실행 파일을 시작할 때 토큰과 이메일을 넘긴다.
3. 실행 파일이 시작될 때, 이메일의 파싱해서 저장하고 토큰을 파싱해 어플리케이션 서버로 검증을 요청한다.
4. 검증에 성공했을 때만 필드로 진입한다.

## 컨텐츠
### 플레이어
- 로그인할 때 사용한 이메일의 @와 도메인을 제외한 부분을 플레이어 이름으로 표기한다.
- 공격 무기는 **화살**만 가능하며 투사체가 동작하는 모습을 확인할 수 있다.
- 몬스터를 잡으면 **활**, **헬멧**, **갑옷**, **부츠** 등 장비를 획득한다.
- 아이템은 몬스터의 수준에 맞게 세팅된다.
- `ViewCube` 객체를 통해 몬스터와의 가시성을 계산한다.
  - 맵을 가상으로 나눈 `Zone` 단위를 통해 인접 `Zone`에 있는 요소만 렌더링한다.
- 더미 플레이어는 움직이지 않지만 `ViewCube`가 플레이어와 동일한 100ms 주기로 동작한다.

### 몬스터
- **200ms** 주기로 플레이어를 탐색한다.
- **A***를 최적화하여 더미 플레이어를 포함한 플레이어를 추적한다.
- 타겟 플레이어를 발견했지만 도달할 수 없을 때는 가장 가까운 셀에서 대기할 수 있다.
- 플레이어와 특정 거리 이상으로 멀어지면 추격을 중단한다.

### 맵
- 가상의 단위인 `Zone`을 통해 플레이어가 맵에 있는 모든 액터를 렌더링하지 않고 인접 존만 렌더링한다.
  - 인접 `Zone`의 액터에게만 브로드캐스팅한다.
- 맵에서 움직이는 모든 액터들은 `Zone`에 속해 있고 `Zone` 변경이 실시간으로 반영된다.

### ViewCube
- 플레이어의 인접 `Zone`에 있는 액터들을 구해 **100ms** 단위로 화면을 갱신한다.
- 갱신할 때 추가된 액터는 스폰을 하고 사라진 액터는 디스폰한다.

## 패킷 모아보내기
- 극단적인 반응성이 중요할 때는(FPS 등) 패킷 모아보내기를 적용하지 않아야 하겠지만, **MMORPG**에서는 많은 패킷을 빠르게 처리하는 건 무시할 수 없는 성능 지표가 된다.
- **CPU 바운드**가 **IO 바운드**보다 압도적으로 빠르기 때문에 이를 활용해 패킷을 모아보낸다.
  - **바이트 수**와 **시간 간격** 두 요소를 함께 사용해 패킷이 빨리 쌓이면 빨리 보내고 덜 쌓이더라도 시간 제한을 둔다.
- `PacketManager`를 통해 특정 주기 단위로 패킷이 송신이 이뤄지도록 한다.

## 스마트 포인터로 객체 수명 관리
- 메모리 해제를 수동으로 하지 않고 레퍼런스 카운트로 자동 관리한다.

## 복사 비용 최소화
- 복사 비용을 최소화하기 위해 **RVO**와 **이동 연산자**를 적극 사용한다.

## Protobuf 사용
- 유니티 클라이언트와의 원활한 통신을 위해 **protobuf**를 사용한다.
- 코드 자동화와 bat 파일 등을 사용해 패킷이 변경되면 서버와 클라이언트에 동시에 반영될 수 있도록 한다.